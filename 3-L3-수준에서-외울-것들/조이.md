## 1. IPv4 주소의 기본 구조
> **Keypoint**
> * IP 주소는 `network 주소`와 `host 주소`로 이루어져 있다.
> * 8 bit씩 끊어서 `.`(dot) 으로 나누며, 범위는 `0 ~ 255` 이다.


* `MAC 주소`는 `48 bit` 이고, `IPv4`는 `32bit(8bit * 4)` 이다.  
    `8bit`로 표현할 수 있는 범위는 0(`0000 0000`)~255(`1111 1111`)이다.


* IP 주소: `Network ID` + `Host ID`
  * IP 주소는 host에 대한 식별자이다.
  * 택배로 예를 들면 네트워크 ID는 1차 목적지, 호스트 ID는 구체적인 주소로 볼 수 있다.
  * IP 주소는 8bit씩 끊어서 `.`(dot)으로 구분한다. IP 주소의 앞쪽 `24bit`는 `network ID`, 뒷쪽 `8bit`는 `host ID`이다.
    * 예: `192.168.0.10` → `1100 0000` `1010 1000` `0000 0000` `0000 1010`
    * 위의 예시에서 `192.168.0` 가 `network ID` 이며, `10` 이 `host ID` 이다.

<br><br>

## 2. L3 IP Packet으로 외워라
### Packet
> `Packet`은 `L3 IP Packet` 으로 외우자! (연관하여 기억하기)  
> `Header` + `Payload`로 구성되어 있다. 이는 상대적인 분류 이다.  
> 최대 크기를 `MTU`라고 한다.  

* `Packet`은 단위 데이터이며, 퍼즐 한 조각 또는 택배 박스 등으로 비유할 수 있다.  
* `Header`에는 출발지(`Src`)와 목적지(`Dst`)에 대한 정보가 담겨있고, `Payload`에는 데이터가 담겨있다.  
  쉽게 생각하면 `header`는 운송장, `payload` 는 데이터로 볼 수 있다.    
* `MTU`는 보통 `1500 bytes`로 매우 작다.  

* cf) `wire shark`: 네트워크 확인 가능한 분석 프로그램  

<br><br>

## 3. Encapsulation과 Decapsulation
* `Encapsulation` 은 데이터를 감싸는 것, 그리고 `Decapsulation`은 데이터를 꺼내는 것으로 표현할 수 있다.  
* 상위 레이어의 데이터(Header + Payload)를 Payload에 가진다.   
  예) `L2 Frame`의 `Payload`에 `IP Packet`이 통째로 포함되어 있고, `L3`에는 `L4`의 `TCP Segment`가 담겨 있다. 

<br><br>

## 4. 패킷의 생성, 전달, 소멸
> 패킷의 생성, 전달, 소멸 과정을 이해하기 위해 아래의 예시를 먼저 생각해보자.  
> `철수`가 `영희`에게 `책`을 `택배`로 보내는 과정을 생각해본다.    

* `철수`는 `책`을 `박스`에 넣고 `송장`을 붙인다.
* 이 때, 송장에는 출발지, 도착지, 보내는 사람, 받는 사람이 기재되어 있다.  
* `철수의 집`에서 `택배`를 `택배 기사님`에게 전달한다.
* `택배 기사님`은 각 `집`들의 `택배`들을 취합해서 하나의 `트럭`으로 이동한다.
* `택배`들을 `트럭`을 타고 `택배사`로 도착하고, 물류 체계에 따라 분류 되어 배송된다.  
* `송장`의 정보를 따라 `택배`는 `영희의 집`에 도착한다.
* 영희의 가족들은 송장 속 받는 사람을 확인하고, `영희`에게 전달해준다.

<br><br>

위의 예시 내의 주체와 행위들을 아래와 같이 대체해볼 수 있다.  

* `철수의 집`, `영희의 집`: `host`
* `철수`, `영희` : `process`
* `책`: `data`
* `택배(박스)` : `packet`
* `택배 기사` : `gateway`
* `택배들을 분류해서 보내는 것` : `routing`
* `받는 사람` : `port`

<br><br>

그리고 그림으로 정리해보면 아래와 같다.   

![패킷_전달과정_예시.jpeg](%EC%9D%B4%EB%AF%B8%EC%A7%80%2F%ED%8C%A8%ED%82%B7_%EC%A0%84%EB%8B%AC%EA%B3%BC%EC%A0%95_%EC%98%88%EC%8B%9C.jpeg)




<br><br><br><br>

## 5. 계층별 데이터 단위
만약 브라우저로 인터넷 정보 송수신을 한다면 `socket`을 통해 정보를 송수신할 것이다.
이 때, 아래와 같이 각 계층별로 데이터의 단위의 차이가 있다. 

* `L1~L2` : `Frame` 
* `L3(IP)`: `Packet` / `MTU`(패킷의 최대 크기, 1500 bytes)  
* `L4(TCP)`: `Segment` / `MSS`(세그먼트의 최대 크기, 1460 bytes)  
* `Usermode(Socket 수준)`: `Stream`   

엄밀히 말하면 스트림은 데이터 단위라고 보기에는 어려움이 있다.  
Segment부터 데이터의 단위로 본다.  

<br><br>

### 분할
MTU, MSS와 같이 각 계층의 전송 가능한 데이터 크기가 제한적이므로, 크기가 큰 스트림을 분할하여야 한다.  
분할은 스트림이 세그먼트화될 때 (Socket → TCP) 일어난다.  

이 때, Socket은 인터페이스이며, File의 일종으로 볼 수 있다.  
소켓은 Kernel mode TCP를 추상화 한 것이고, 유저모드에서 커널 모드로 접근할 수 있도록 한다.      

cf) `datagram` (UDP 프로토콜)

<br><br>

### `Stream`

  * 시작은 있지만 끝을 정의할 수 없다.
  * `Stream`의 끝은 process(application)에 의해 정해진다. 
  * 연속적으로 이어진 크기를 알수 없는 큰 데이터이다.  

<br><br><br><br>

## 6. 이해하면 인생이 바뀌는 TCP/IP 송수신 구조
> 만약 우리가 브라우저에서 어떤 파일을 다운 받으려고 한다.  
> 이 때, 다운받을 파일과 packet의 MTU 차이가 너무 크다면 어떻게 작동될까?  
> TCP 연결이 되었다는 가정 하에 송수신이 진행 과정을 생각해보자.  


먼저 server를 생각해보자.  
서버 컴퓨터에는 HDD,SSD 가 있고, 여기에 있는 데이터(다운로드 할 파일)를 우리는 클라이언트에게 전달해주어야한다.
이 때, 해당 데이터가 메모리 공간(buffer)에 올라가게 되고, 소켓의 입출력을 통해 데이터 송신 과정이 진행된다.  

cf) socket에도 buffer가 있고 server에도 buffer가 있다.  
개발자가 이 server의 buffer(process와 연결된)를 관리하며, 해당 버퍼의 사이즈는 개발자가 정한다.  
만약 소켓에서 buffer를 사용하면 buffered i/o, 아니면 non-buffered i/o 라고 한다.
server buffer에서 send 결정이 나면 socket buffer로 copy가 일어난다.  
이 때의 데이터가 stream이고, stream에는 번호가 붙는다.  
이 stream은 segment화를 거쳐 순차적으로 encapsulation이 일어난다. 
그리고 송신측에서 수신측으로 이동하는 과정에서 frame이 변경된다.  


반대로 수신측에서는 decapsulation이 일어난다.  
수신하면 socket i/o에서 proccess buffer로 receive(read)한다.
네트워크에서는 소켓 버퍼를 계속 채우고, 프로세스는 버퍼를 계속 비워내는 것이다.
데이터를 수신하고 buffer를 채우는 과정에서 때 속도차가 발생할 수 있다.      

송신측에서는 1번 패킷을 보내고 별다른 일이 없다면 다음 데이터를 바로 보낸다.  
TCP는 연결지향이기 때문에 수신측이 잘 받았다면 피드백(ack)을 준다.  
`ack #3` 와 같이 응답한다(어디까지 수신했는지 알려줌).  
송신측은 ack를 기다리다가 받으면 다음 걸 보낸다.  
수신측이 ack를 보낼 때는 여유공간 (socket buffer)도 함께 보낸다.  
여유공간이 없으면 송신측은 데이터를 못 보내기 때문이다.
네트워크는 생각보다 불안정하다.  


<br><br><br><br>

### TCP 통신 시 network에서 발생할 수 있는 장애
* `loss` → `네트워크` 상 이슈
*  `retransmission`
   * 송신자가 데이터를 보냈을 때, 일정 시간이 지나도 수신자의 응답이 없으면 다시 보내는 것이다.
   * 이 때, 간발의 차로 `ack`를 보내서 `ack duplicate` 가 발생할 수 있다. → `네트워크` 또는 `엔드포인트` 상 이슈

*  `out of order`
   * `1-2-3-4`순서로 받아야하는데 `1-2-4`와 같이 `3`을 누락해서 받거나, `1-2-4-3`처럼 순서가 잘못된 상태로 수신하는 것을 말한다.
   * 운영체제 수준에서 보정할 수 있다. → 거의 `네트워크` 상 이슈

*  `zero window`
  * 여유공간(window size)이 full이 나면 발생(네트워크 송수신 속도가 프로세스가 read하는 속도보다 빠른 경우) → `end-point의 application` 문제

<br><br><br><br>

## 7. IP 헤더 형식

### IPv4 Header 형식

* `MTU` : 통상적으로 1500 bytes
* IP Header: 옵션이 안 붙으면 20 bytes
* IHL(Internet Header Length): 5행 → 5*4 → 20 bytes
* total length: 패킷의 길이 → 16bit 2에 16제곱 - 헤더 길이 → 64kb가 가장 큰 숫자
* fragment offset - > 단편화와 관련되어 있다. mtu가 작으면 패킷을 또 자르는 것이다.  
* ttl → ttl 값이 0이 되면 패킷이 버려지고, 홉이라는 단위를 지날 때마다 감소함
* protocol → payload 내부에 있는 header를 뭘로 볼건지 등에 대한 내용
* checksum → 네트워크로 데이터 송수신하는 과정에서 손상이 일어났을 까봐 검사하는 값
