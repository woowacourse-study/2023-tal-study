## 1. IPv4 주소의 기본 구조
> **Keypoint**
> * IP 주소는 `network 주소`와 `host 주소`로 이루어져 있다.
> * 8 bit씩 끊어서 `.`(dot) 으로 나누며, 범위는 `0 ~ 255` 이다.


* `MAC 주소`는 `48 bit` 이고, `IPv4`는 `32bit(8bit * 4)` 이다.  
    `8bit`로 표현할 수 있는 범위는 0(`0000 0000`)~255(`1111 1111`)이다.


* IP 주소: `Network ID` + `Host ID`
  * IP 주소는 host에 대한 식별자이다.
  * 택배로 예를 들면 네트워크 ID는 1차 목적지, 호스트 ID는 구체적인 주소로 볼 수 있다.
  * IP 주소는 8bit씩 끊어서 `.`(dot)으로 구분한다. IP 주소의 앞쪽 `24bit`는 `network ID`, 뒷쪽 `8bit`는 `host ID`이다.
    * 예: `192.168.0.10` → `1100 0000` `1010 1000` `0000 0000` `0000 1010`
    * 위의 예시에서 `192.168.0` 가 `network ID` 이며, `10` 이 `host ID` 이다.

<br><br>

## 2. L3 IP Packet으로 외워라
### Packet
> `Packet`은 `L3 IP Packet` 으로 외우자! (연관하여 기억하기)  
> `Header` + `Payload`로 구성되어 있다. 이는 상대적인 분류 이다.  
> 최대 크기를 `MTU`라고 한다.  

* `Packet`은 단위 데이터이며, 퍼즐 한 조각 또는 택배 박스 등으로 비유할 수 있다.  
* `Header`에는 출발지(`Src`)와 목적지(`Dst`)에 대한 정보가 담겨있고, `Payload`에는 데이터가 담겨있다.  
  쉽게 생각하면 `header`는 운송장, `payload` 는 데이터로 볼 수 있다.    
* `MTU`는 보통 `1500 bytes`로 매우 작다.  

* cf) `wire shark`: 네트워크 확인 가능한 분석 프로그램  

<br><br>

## 3. Encapsulation과 Decapsulation
* `Encapsulation` 은 데이터를 감싸는 것, 그리고 `Decapsulation`은 데이터를 꺼내는 것으로 표현할 수 있다.  
* 상위 레이어의 데이터(Header + Payload)를 Payload에 가진다.   
  예) `L2 Frame`의 `Payload`에 `IP Packet`이 통째로 포함되어 있고, `L3`에는 `L4`의 `TCP Segment`가 담겨 있다. 

<br><br>

## 4. 패킷의 생성, 전달, 소멸
> 패킷의 생성, 전달, 소멸 과정을 이해하기 위해 아래의 예시를 먼저 생각해보자.  
> `철수`가 `영희`에게 `책`을 `택배`로 보내는 과정을 생각해본다.    

* `철수`는 `책`을 `박스`에 넣고 `송장`을 붙인다.
* 이 때, 송장에는 출발지, 도착지, 보내는 사람, 받는 사람이 기재되어 있다.  
* `철수의 집`에서 `택배`를 `택배 기사님`에게 전달한다.
* `택배 기사님`은 각 `집`들의 `택배`들을 취합해서 하나의 `트럭`으로 이동한다.
* `택배`들을 `트럭`을 타고 `택배사`로 도착하고, 물류 체계에 따라 분류 되어 배송된다.  
* `송장`의 정보를 따라 `택배`는 `영희의 집`에 도착한다.
* 영희의 가족들은 송장 속 받는 사람을 확인하고, `영희`에게 전달해준다.

<br><br>

위의 예시 내의 주체와 행위들을 아래와 같이 대체해볼 수 있다.  

* `철수의 집`, `영희의 집`: `host`
* `철수`, `영희` : `process`
* `책`: `data`
* `택배(박스)` : `packet`
* `택배 기사` : `gateway`
* `택배들을 분류해서 보내는 것` : `routing`
* `받는 사람` : `port`

<br><br>

그리고 그림으로 정리해보면 아래와 같다.   

![패킷_전달과정_예시.jpeg](%EC%9D%B4%EB%AF%B8%EC%A7%80%2F%ED%8C%A8%ED%82%B7_%EC%A0%84%EB%8B%AC%EA%B3%BC%EC%A0%95_%EC%98%88%EC%8B%9C.jpeg)




<br><br><br><br>

## 5. 계층별 데이터 단위
만약 브라우저로 인터넷 정보 송수신을 한다면 `socket`을 통해 정보를 송수신할 것이다.
이 때, 아래와 같이 각 계층별로 데이터의 단위의 차이가 있다. 

* `L1~L2` : `Frame` 
* `L3(IP)`: `Packet` / `MTU`(패킷의 최대 크기, 1500 bytes)  
* `L4(TCP)`: `Segment` / `MSS`(세그먼트의 최대 크기, 1460 bytes)  
* `Usermode(Socket 수준)`: `Stream`   

엄밀히 말하면 스트림은 데이터 단위라고 보기에는 어려움이 있다.  
Segment부터 데이터의 단위로 본다.  

<br><br>

### 분할
MTU, MSS와 같이 각 계층의 전송 가능한 데이터 크기가 제한적이므로, 크기가 큰 스트림을 분할하여야 한다.  
분할은 스트림이 세그먼트화될 때 (Socket → TCP) 일어난다.  

이 때, Socket은 인터페이스이며, File의 일종으로 볼 수 있다.  
소켓은 Kernel mode TCP를 추상화 한 것이고, 유저모드에서 커널 모드로 접근할 수 있도록 한다.      

cf) `datagram` (UDP 프로토콜)

<br><br>

### `Stream`

  * 시작은 있지만 끝을 정의할 수 없다.
  * `Stream`의 끝은 process(application)에 의해 정해진다. 
  * 연속적으로 이어진 크기를 알수 없는 큰 데이터이다.  

<br><br><br><br>

## 6. 이해하면 인생이 바뀌는 TCP/IP 송수신 구조
> 만약 우리가 브라우저에서 어떤 파일을 다운 받으려고 한다.  
> 이 때, 다운받을 파일과 packet의 MTU 차이가 너무 크다면 어떻게 작동될까?  
> TCP 연결이 되었다는 가정 하에 송수신이 진행 과정을 생각해보자.  


먼저 server를 생각해보자.  
서버 컴퓨터에는 HDD,SSD 가 있고, 여기에 있는 데이터(다운로드 할 파일)를 우리는 클라이언트에게 전달해주어야한다.
이 때, 해당 데이터가 메모리 공간(buffer)에 올라가게 되고, 소켓의 입출력을 통해 데이터 송신 과정이 진행된다.  

cf) socket에도 buffer가 있고 server에도 buffer가 있다.  
개발자가 이 server의 buffer(process와 연결된)를 관리하며, 해당 버퍼의 사이즈는 개발자가 정한다.  
만약 소켓에서 buffer를 사용하면 buffered i/o, 아니면 non-buffered i/o 라고 한다.
server buffer에서 send 결정이 나면 socket buffer로 copy가 일어난다.  
이 때의 데이터가 stream이고, stream에는 번호가 붙는다.  
이 stream은 segment화를 거쳐 순차적으로 encapsulation이 일어난다. 
그리고 송신측에서 수신측으로 이동하는 과정에서 frame이 변경된다.  


반대로 수신측에서는 decapsulation이 일어난다.  
수신하면 socket i/o에서 proccess buffer로 receive(read)한다.
네트워크에서는 소켓 버퍼를 계속 채우고, 프로세스는 버퍼를 계속 비워내는 것이다.
데이터를 수신하고 buffer를 채우는 과정에서 때 속도차가 발생할 수 있다.      

송신측에서는 1번 패킷을 보내고 별다른 일이 없다면 다음 데이터를 바로 보낸다.  
TCP는 연결지향이기 때문에 수신측이 잘 받았다면 피드백(ack)을 준다.  
`ack #3` 와 같이 응답한다(어디까지 수신했는지 알려줌).  
송신측은 ack를 기다리다가 받으면 다음 걸 보낸다.  
수신측이 ack를 보낼 때는 여유공간 (socket buffer)도 함께 보낸다.  
여유공간이 없으면 송신측은 데이터를 못 보내기 때문이다.
네트워크는 생각보다 불안정하다.  


<br><br><br><br>

### TCP 통신 시 network에서 발생할 수 있는 장애
* `loss` → `네트워크` 상 이슈
*  `retransmission`
   * 송신자가 데이터를 보냈을 때, 일정 시간이 지나도 수신자의 응답이 없으면 다시 보내는 것이다.
   * 이 때, 간발의 차로 `ack`를 보내서 `ack duplicate` 가 발생할 수 있다. → `네트워크` 또는 `엔드포인트` 상 이슈

*  `out of order`
   * `1-2-3-4`순서로 받아야하는데 `1-2-4`와 같이 `3`을 누락해서 받거나, `1-2-4-3`처럼 순서가 잘못된 상태로 수신하는 것을 말한다.
   * 운영체제 수준에서 보정할 수 있다. → 거의 `네트워크` 상 이슈

*  `zero window`
  * 여유공간(window size)이 full이 나면 발생(네트워크 송수신 속도가 프로세스가 read하는 속도보다 빠른 경우) → `end-point의 application` 문제

<br><br><br><br>

## 7. IP 헤더 형식

### IPv4 Header 형식

* `MTU` : 통상적으로 1500 bytes
* IP Header: 옵션이 안 붙으면 20 bytes
* IHL(Internet Header Length): 5행 → 5*4 → 20 bytes
* total length: 패킷의 길이 → 16bit 2에 16제곱 - 헤더 길이 → 64kb가 가장 큰 숫자
* fragment offset - > 단편화와 관련되어 있다. mtu가 작으면 패킷을 또 자르는 것이다.  
* ttl → ttl 값이 0이 되면 패킷이 버려지고, 홉이라는 단위를 지날 때마다 감소함
* protocol → payload 내부에 있는 header를 뭘로 볼건지 등에 대한 내용
* checksum → 네트워크로 데이터 송수신하는 과정에서 손상이 일어났을 까봐 검사하는 값

## 8. Subnet Mask
- IP 주소에서 서브넷 마스크를 이용해서 비트단위로 AND 연산을 한다.
    - 네트워크 장비 등에 패킷이 오면 넷마스크와 and 연산을 한다.
    - 네트워크 id가 자신과 일치하면 유입이 될 것을 판단한다 (마스크 연산을 통해 자신의 네트워크에 오는 패킷인지 판단)  
- ip 주소에 클래스 개념을 매겨서 등급을 정하기도 했었다.
    - 요즘엔 클래스 개념을 사용하지 않는다.
    - 넷마스크 개념도 요즘엔 달라졌다(클래스리스) → CIDR


## 9. CIDR(Classless Inter-Domain Routing)
- `192.168.0.10/24` 와 같이 IP 주소가 있을 때, `/` 뒤에 오는 숫자가 매우 중요하다.  
- 예시를 통해 살펴보면, `/24` 는 24 bit까지 네트워크 id 라고 인지하겠다는 뜻이다 (8bit *3)
- 이로 인해, 이제 마스크 연산을 통해 네트워크 id를 확인하지 않고, `/` 뒤에 쓰인 값만 보고 `==` 연산을 통해 알아낼 수 있다.  
- `서브네팅` 이라는게 있다. 알고만 넘어가자.

## 10. Broadcast IP 주소
- 브로드캐스팅은 전체에 다 전송하겠다는 의미이다.
- 비슷한 개념으로 `multicasting`이 있다. 
- 브로드캐스트는 효율이 떨어진다. 그렇기 때문에 통제가 필요하다.
- 브로드캐스트 시 네트워크 장치들에 부담이 된다. 
- 브로드캐스트가 늘어나면 부하가 올라가고 효율이 떨어진다.
- 그렇기 때문에 안 할 수 있으면 안 하는 것이 좋다.


- `192.168.0.255` → 브로드캐스트 주소이기 때문에 사용하지 않음
- `192.168.0.0` → 서브넷 마스크 결과와 일치해서 사용하지 않음
- `192.168.0.1` → 게이트웨이로 역시 사용하지 않음
- 사용할 수 있는 호스트 ip주소는 결과적으로 253개이다(256-3)

## 11. Host 자신을 가리키는 IP주소
`127.0.0.1`는 host 자신을 가리키는 ip 주소이다.  
- host 가 자신에게 접속(이 주체는 프로세스)해야할 때 사용하는 ip 주소
- loopback address
- 같은 pc 내의 프로세스 간 통신을 할 때 사용
- IPC (inter process communication)

## 12. TTL 과 단편화
- 인터넷은 라우터의 집합체라고 할 수 있는 논리 네트워크이다.
- 라우터 vs L3 스위치
  - 관점에 따라 라우터가 L3 스위치에 포함될수도, 그 반대가 될수도 있다.
  - 강사의 생각은 둘을 구별하는게 의미가 없을 것 같다.
  - 오히려 개념적으로 봤을 때 L3 스위치에 포함된다고 생각
- 인터넷의 핵심 구성요소 → 라우터 + DNS
- 라우터가 하는 일은 라우팅 → 정보를 자신이 수집하는 것이 아니라 거쳐가는 곳
- 이동의 단위는 TTL


- TTL(Time To Live)는 세포의 텔로미어 같은 역할
- 단편화는 MTU 크기 차이로 발생
- 보통 단편의 조립은 수신측 Host에서 이뤄짐

패킷은 목적지를 찾아 인터넷을 돌아다닌다.  
목적지 찾는 것을 실패한다면 빨리 버리고 폐기 시켜야한다.   
그렇지 않으면 좀비 패킷들이 늘어날 수 있기 때문이다(그럼 인터넷이 다운될 수 있음)  
이걸 막기 위한 것이 TTL 이다.  

라우터에서 라우터를 지날 때의 단위는 홉이다.  
라우터를 지날 때마다 TTL이 줄어든다 (홉 만큼).  
라우터가 최초 출발지에 패킷 폐기에 대해 이야기해주기도 한다 (보안상의 이유 때문에 안 할 때도 있다).  

MTU 가 크기가 작으면 단편화가 발생한다. (패킷을 자름)  
예를 들어, 송신측 에서 MTU가 1500인 패킷을 보냈는데, 라우터 경로에 있는 하나의 라우터가 MTU가 1400이라면 단편화가 발생할 수 있다.  
단편화가 일어나면 2개 이상의 패킷으로 분리된다.  
이 때, 해당 패킷들은 수신측에서 조립한다.

단편화가 일어나는 것은 좋지 않다. 그렇기 때문에 보낼 때 사이즈를 고려해서 보내는 것이 좋다.  
하지만, 최근에는 MTU가 대부분 1500이다.   
그럼에도 이보다 작은 경우가 있는데 대표적으로 VPN 가 있다.  
IPSec 터널링이 적용되면 단편화 발생할 수 있다.  

## 13. 인터넷 설정 자동화를 위한 DHCP
host를 유니크하게 식별하는 건 IP주소 (32bit)이다.
인터넷을 제공해주는 곳은 ISP (internet service provider)이다.
인터넷을 사용할 때 설정해줘야하는 것은 `L3 설정 (IP, Subnet mask, gateway IP) + DNS 설정`가 있다.
보통은 DHCP를 통해 자동 설정한다.  


- DHCP(Dynamic Host Configuration Protocol) 체계는 주소를 할당하는 서버와 할당 받으려는 클라이언트로 구성된다.
- 복잡한 인터넷 설정을 자동으로 해준다고 볼 수 있는데 핵심은 내가 사용할 IP 주소를 서버가 알려준다는 것에 있다.
- 컴퓨터 구동 중에 설정된다.  
- DHCP 서버를 찾을 때는 브로드캐스트를 이용한다.  
- DHCP를 처음 찾고 나서, 이후에 또 필요할 때는 기억하고 있다가 이전에 응답한 서버에 다시 사용해도 되는지 물어본다.  
- DHCP 서버를 알아낸 후엔 설정해야 할 정보들을 다 보낸다.
- DHCP 서버는 IP 풀을 가지고 있고, 이를 통해 중복이 안 생기도록 관리한다.
- 참고로 DHCP 서버를 찾을 때는 브로드캐스트 도메인(G.W)을 넘어가서 응답을 받을 수 없다.

## 14. ARP(Address Resolution Protocol)
- ARP는 IP주소로 MAC주소를 알아내려할 때 활용된다.
- 보통의 경우 PC를 부팅하면 Gateway의 MAC주소를 찾아내기 위해 ARP Request가 발생하며 이에 대응하는 Reply로 MAC주소를 알 수 있다.
- 이 때 address는 IP주소와 Mac 주소를 의미한다.
- 일반적으로 IP주소 + Mac 주소는 쌍을 이룬다. (L3 + L4)
- 게이트웨이 MAC주소를 모르면 인터넷을 할 수 없다.  
- 게이트웨이 MAC주소를 알기위해 ARP 리퀘스트를 브로드캐스트로 보낸다.
- L2 프레임의 목적지는 최종 목적지가 아니라 게이트웨이 맥 주소이다.  
- DHCP 를 통해 게이트 웨이 찾고, 게이트웨이에 맥주소 물어봄(arp 리퀘스트)
- arp 캐시를 통해 스스로 결정된 주소를 가지고 통신한다.  


## 15. Ping 과 RTT
- Ping 유틸리티(그냥 프로그램)는 특정 Host에 대한 RTT(Round Trip Time)을 측정할 목적으로 사용된다.
- ICMP 프로토콜을 이용한다.
- DoS(Denial of Service) 공격용으로 악용되기도 한다.

- 서버와의 연결 상태를 확인하는 것이 ping이다.  
- RTT로 네트워크 통신 속도를 측정한다.  
- 거리에 따라(멀면) 속도가 느려질수도 있다.  
- ping 자체는 프로토콜이 아니고 유틸 프로그램이라는 것을 잊지말자.  
