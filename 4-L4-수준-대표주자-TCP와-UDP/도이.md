# 4. L4 수준 대표주자 TCP와 UDP

## TCP와 UDP
- 이 두 가지는 L4 계층의 대표적인 프로토콜이다.
- 둘 중 TCP에만 연결(Connection, Session) 개념이 있다.
  - 이 때 연결이란, '논리적' 개념이다.
  - 연결은 순서를 가진다.
  - 연결은 '상태(전이)' 개념을 동반한다. -> 전화 통화에 비유해보자. 전화 통화는 연결 전, 후 상태 변화를 가진다.
- TCP는 상대가 데이터를 수신하지 못하면, Zero Window를 방지하기 위해 데이터를 더 보내지 않는다. 하지만 UDP는 무조건 보낸다.

### TCP 연결방식
- 기본적으로 클라이언트와 서버로 구성된다.
- 클라이언트의 프로세스가 소켓을 연다.
  - 프로세스는 PID를 가진다. 운영체제에서 이 프로세스에게 TCP 포트번호를 부여한다.
- 서버의 프로세스에서도 LISTEN 상태의 소켓을 열고 연결 대기한다.
  - 이 프로세스도 TCP 포트번호를 가지는데, 웹 서버의 경우 일반적으로 80번이다.
  - 클라이언트에서는 서버의 IP주소와 포트번호를 알아야 연결을 시도할 수 있다.

> UDP는 연결 개념이 없지만, Socket 통신을 한다는 점, 포트번호를 부여한다는 점은 동일하다.

## TCP 연결과정 (3-way handshaking)
- TCP 연결 과정에서 주고 받는 Segment는 payload가 없이, 헤더만 가지고 있다. (관리 목적으로 주고받는 데이터)
- 이 연결에서 이루어지는 것은 아래와 같다.
  - Sequence 번호 교환
  - 프로토콜이 규정하는 정책을 교환
    - 특히 중요한 정책 교환으로는 MSS 확인 이 있다.

<img width="526" alt="image" src="https://github.com/yoondgu/seoulchoice/assets/97426362/be4adb1e-89e5-444a-b6e8-595e63dd6163">

  1. 클라이언트가 랜덤하게 생성한 시퀀스번호(SYN)를 서버에 보낸다.
  2. 서버는 해당 번호에 1 증가한 값과(ACK), 서버에서 랜덤하게 생성한 시퀀스 번호(SYN)로 응답한다.
  3. 클라이언트는 서버의 시퀀스번호에 1 증가한 값(ACK)으로 응답한다.

> 클라이언트는 2번에서 응답을 받았을 때, 서버는 3번에서 응답을 받았을 때 연결이 되었다고 판단한다. -> 서로 시간차가 발생한다.  
> 이 때 연결은 물리적 연결이 아니라 virtual circuit, 논리적 연결이다.

## TCP 연결종료 (4-way handshaking)
- 대전제
  - TCP 프로토콜에서 연결을 시작하는 주체, 종료하는 주체는 모두 클라이언트이다.

<img width="526" alt="image" src="https://github.com/yoondgu/seoulchoice/assets/97426362/f210f19e-d84f-4f7b-99c1-df2765939978">

1. 클라이언트가 서버에 FIN + ACK를 보낸다.
2. 이를 확인한 서버는 ACK를 보낸다. 
3. 마찬가지로 서버에서도 클라이언트에 FIN + ACK를 보낸다.
4. 이를 확인한 클라이언트가 ACK를 보낸다.
5. 클라이언트 측에서는 TIME WAIT이 발생하고, 서버에서 ACK를 확인하면 양측 모두 종료됨. -> 소켓 회수

- 서버에서 TIME WAIT이 발생했다면, 서버에서 종료를 먼저 시작한 것이므로 일반적인 상황은 아님을 알 수 있다.
- TIME WAIT 동안 소켓이 낭비되기 때문에 서버가 아닌 클라이언트가 종료하도록 유도해야 한다. (클라이언트 - 서버는 1:n 관계니까?)

## TCP, UDP 헤더형식과 게임서버 특징
### TCP 헤더 형식
- Source port, Destination port
  - 사용 가능한 포트번호 개수 : 2^16 - 2 (0, 65535 제외)
- Sequence Number
- Acknowlodgement number
- Data offset : payload 위치 계산
- Flag 값들 : TCP의 상태를 표현, 혼잡 제어 (SYN, ACK, FIN도 이 중 하나)
- Window Size : 여유공간
- Checksum : 데이터 손상여부 확인
- 등등

### UDP 헤더 형식
- Source port, Destination port
- Length
- Checksum
- 이것 뿐이다. 매우 간단하다. TCP와 달리 혼잡 제어를 하지 않는다.
- 사용 예시
  - 연결이 느린 클라이언트까지 모두 고려하지 않고, 연결이 되는 곳에 먼저 데이터를 빨리 보내는 게 더 중요할 때는 TCP보다 UDP가 적합하다.
  - 멀티 미디어 전송에 최적화되어 있다.
    - IPTV 영상 송출
    - 게임 서버 : TCP를 이용하면 모든 연결 속도가 하향평준화된다.
    - HTTP3

## TCP '연결'이라는 착각
### 파일 다운로드 중 LAN 케이블을 분리했다가 다시 연결하면, TCP 연결은 어떻게 될까?
- 결론적으로, TCP 연결은 일정 시간 동안 유지된다. (랜선을 분리한 시간에 따라서 다르다.)
- 따라서 다시 연결하면 다시 다운로드가 진행된다.
- 하지만 연결이라는 것을 너무 믿지 말자. 연결은 착각이다.
  - 대부분의 운영체제들은 1초 미만의 속도로 재전송을 한다.
  - 물리적 연결처럼 계속 유지되고 있어서 다운로드가 다시 진행되는 게 아니다.
  - 끊임없이 재전송을 요청하기 때문에 연결이 '유지'된 것처럼 보이는 것이다.
  - 따라서 사실 **연결은 End-point의 주관적 판단에 불과하다.**
> 프로토콜 구현 내용이 표준과 차이가 있을 수 있기 때문에, 프로세스에서는 3-way handshaking이 완료되었더라도 연결 여부를 지속적으로 재확인한다. (이를 heartbeat이라 한다)  
> 강의에서는 "RFC 문서 표준과 실제 프로토콜 구현이 다를 수 있다"고 하는데 구현이 다르다는 게 어떤 의미인지?

## TCP 연결과 게임버그
- 이전 챕터에서 얘기한 현상을 악용하는 것이 게임 아이템 복제 버그이다.
- 연결이 되었다고 End-point에서 주관적으로 판단할 뿐이기 때문에, 보안성이 떨어진다.
  - 마치 전화 통화를 할 때, 목소리만으로 수신자가 내가 전화를 건 사람이 맞다고 판단하는 것과 같다. 목소리 변조, 보이스피싱 등을 고려하지 않는다.