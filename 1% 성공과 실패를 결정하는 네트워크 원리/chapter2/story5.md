# story 5. IP와 이더넷의 패킷 송수신 동작  

## 1. 패킷의 기본  
> TCP 담당 부분은 각 단계에서 IP 담당 부분에 의뢰하여 데이터를 패킷의 모습으로 만들어 보낸다.  
> IP 담당부분이 어떻게 패킷을 상대에게 송수신하는지 알아보자.  

패킷은 헤더와 데이터로 구성된다.  
* 헤더: 수신처 주소 등의 제어 정보가 있음
* 데이터: 패킷으로 운반할 데이터

* 패킷의 기본형: 헤더 + 데이터
* TCP/IP 패킷
  * 이더넷 패킷
    * 헤더: MAC 헤더 (이더넷 제어 정보)
    * 데이터: IP 패킷
  * IP 패킷
    * 헤더: IP 헤더 (IP 제어 정보)
    * 데이터: TCP 헤더 + 데이터 조각

### 패킷 송수신 과정
* 송신처에서 패킷 생성 후 가까운 중계 장치에 송신
* 중계 장치는 패킷의 헤드를 조사 후 목적지 판단
  * (수신처 방향에 대한 정보를 가진) 표에서 수신처를 찾는다.
* 다음 중계 장치로 패킷을 보낸다.
* 차례로 패킷을 중계하면 최종적으로 수신처의 기기에 패킷이 도착한다.
* 수신처에서 송신처를 향해 회답 패킷을 보낸다.
  * 이런 특징으로 송신처와 수신처를 명확하게 구별하지 않기도 한다. 
  * 송신처와 수신처를 엔드 노드라고 한다.

### 라우터와 허브
> 서브넷은 라우터와 허브라는 두 종류의 패킷 중계 장치에서 아래와 같은 역할을 한다.  

* 라우터가 목적지를 확인하여 다음 라우터를 나타낸다.
  * IP 규칙에 따라 패킷 운반
  * IP가 목적지를 확인하여 다음 IP의 중계 장치를 나타낸다
  
* 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착한다.
  * 허브는 이더넷 규칙에 따라 패킷 운반
  * 서브넷 안에 있는 이더넷이 중계 장치까지 패킷을 운반

### MAC 헤더와 IP 헤더
> MAC 헤더는 이더넷용 헤더이고, IP 헤더는 IP용 헤더이다.  
> 이더넷이 아닌 무선 LAN, ADSL, FTTH 등 IP의 의뢰를 받아 패킷을 운반할 수 있는 것 중 어떤 것을 사용해도 상관 없음. 

패킷 운반에서의 각각의 역할
* 송신처에서 목적지 서버의 IP 주소를 IP 헤더의 수신처에 기록
  * IP는 수신처의 방향을 조사하고, 그 방향의 다음 라우터를 조사
  * 그 라우터의 이더넷 주소를 조사 후 MAC 헤더에 기록
* 패킷은 허브에 도착
  * 허브에서 표와 수신처 정보를 이용해 패킷의 목적지를 판단하고 중계
  * 허브가 복수이면 허브를 순차적으로 경유
* 패킷은 라우터에 도착
  * 표와 수신처 정보를 결합하여 다음 라우터를 결정
  * 다음 라우터의 MAC 주소를 조사 후 MAC 헤더에 기록  
    (수신했을 때의 MAC 헤더는 버리고 새로운 MAC 헤더를 만들고 기록)
  * 패킷을 다음 라우터에 송신
* 앞선 과정을 반복하면 목적지에 도착  


## 2. 패킷 송수신 동작의 개요
> 프로토콜 스택의 IP 담당 부분의 패킷 송신 동작에 대해 알아보자  

### 패킷 송수신
* TCP 담당 부분이 IP 담당 부분에 패킷 송신 의뢰
  * TCP 헤더 + 데이터 조각 을 IP 담당 부분에 전달
* IP 담당 부분은 내용물을 한 덩어리의 디지털 데이터로 간주
  * 앞에 제어 정보를 기록한 헤더 부가(IP 헤더와 MAC 헤더)
* 패킷을 네트워크용 하드웨어로 전달(이더넷, 무선 LAN 등)
    * 이 때 패킷의 모습은 0이나 1비트가 이어진 데이터
    * 이 데이터가 LAN 어댑터에 의해 전기나 빛의 신호 상태로 변경되어 케이블에 송출된다.
    * 신호가 중계 장치에 도착하여 패킷이 전달된다.
* 수신처에서 회답
  * 위 과정이 역순으로 진행된다.
  * 도착한 내용물을 IP 담당 부분이 TCP 담당 부분에게 전달


## 3. 수신처 IP 주소를 기록한 IP 헤더를 만든다  
> TCP 담당 부분이 IP 담당 부분에 의뢰를 하면 IP 헤더를 만들어 TCP 헤더의 앞에 붙인다.  
> IP 헤더에는 다양한 값들이 있고, 그 중 **수신처 IP 주소와 송신처 IP 주소**도 포함되어있다.  

### 수신처 IP 주소  
* **IP는 스스로 수신처를 판단하지 않고**, 애플리케이션이 지정한 상대에게 송신한다.  
* 즉, 잘못된 상황이 발생하면 **애플리케이션측의 책임**으로 간주한다.  

### 송신처 IP 주소
> 하나의 컴퓨터에 여러개의 LAN 어댑터가 장착되어 있다면, IP는 몇 개일까?  

* IP 주소는 컴퓨터에 할당되는 것이 아니라, LAN 어댑터에 할당된다.  
* 여러 개의 LAN 어댑터를 장착하면 각각 서로 다른 IP 주소가 할당되는 것이다.  
* 이 경우, 어느 IP 주소를 설정해야할지 판단해야 한다
  * 어느 LAN 어댑터를 사용해서 패킷을 송신할지 판단하는 것과 같음
  * 패킷을 건네주는 상대의 라우터를 결정하는 것과 같음
  * 상대를 판단하는 방법은 라우터가 라우터 테이블을 이용해 다음 라우터를 결정하는 방법과 동일함


### 라우팅 테이블 살펴보기
> 어떤 LAN 어댑터에서 패킷을 송신해야 하는지 확인한 후 LAN 어댑터에 할당 되어 있는 IP 주소를 IP 헤더의 송신처 IP 주소로 설정한다.  

* 수신처 IP의 왼쪽 부분과 라우팅 테이블의 `Network Destination` 항목 비교
* `Interface`(LAN 어댑터 등의 네트워크용 인터페이스)는 인터페이스에서 패킷을 송신하면 상대에게 패킷을 전해줄 수 있다는 의미
* `Gateway`: 다음 라우터의 IP주소가 기록되어 있음
* 라우팅 테이블 맨 위 행에는 목적지와 `넷 마스크`가 `0.0.0.0` 으로 등록되어 있고, 기본 게이트웨이를 나타낸다.  
  * 다른 곳에 일치하는 것이 없으면 이 행이 해당하는 것으로 간주함  


### 프로토콜 번호
> 패킷의 내용물을 어디서 의뢰 받은 건지 표기  
 
* TCP: 06 (16진수 표기)
* UDP: 17 (16진수 표기)
* 값은 규칙에 결정 되어 있음  



## 4. 이더넷용 MAC 헤더를 만든다.  
> IP 헤더를 만든 후에는 MAC 헤더를 만든다.    
> 이더넷에는 TCP/IP 개념이 통용되지 않는다.  
> 이더넷의 수신처 판단 구조로 사용하는 것이 MAC 헤더 이다.  

### MAC 헤더
> MAC 헤더에는 수신처와 송신처의 MAC 주소, 이더 타입 정보가 있다.  
* IP 주소는 32비트이지만, MAC 주소는 48비트 이다.  
* IP 주소는 `동, 번지` 와 같이 그룹화 개념이지만, MAC 주소는 한 개의 값으로 생각해야 한다.  
* 이더 타입: 내용물이 무엇인지 나타냄. 
  * 내용물은 IP나 ARP라는 프로토콜 소켓이며, 각각 대응하는 값이 규칙으로 정해져 있어서 여기에 값을 기록한다.  

### MAC 헤더 만들기
* 이더 타입 필드에는 프로토콜을 나타내는 값 설정
  * IP 프로토콜: 0800
  * ARP 프로토콜: 0806

* 송신처 MAC 주소
  * 자체 LAN 어댑터의 MAC 주소
  * MAC 주소는 제조할 때 그 안에 있는 ROM에 기록. 이 값을 읽어와서 설정  
  * LAN 어댑터가 여러 개일 경우 LAN 어댑터를 먼저 선택하고 설정

* 수신처 MAC 주소
  * 라우팅 테이블을 통해 패킷을 줄 상대를 조사한다.  
  * 라우팅 테이블에서 gateway 항목에 있는 IP 주소의 기기가 패킷을 넘겨줄 상대가 된다.  
  * 상대의 MAC 주소를 조사해서 헤더에 기록하면 된다.  

## 5. ARP로 수신처 라우터의 MAC 주소를 조사한다.
> 상대의 MAC 주소를 조사할 때 쓰이는 것이 ARP이다.  
> 이더넷에는 연결되어 있는 전체에게 패킷을 전달하는 브로드캐스트라는 구조가 있다.  
> 이를 이용해 상대가 같은 네트워크에 존재한다면 MAC 주소를 알 수 있다.


### ARP 캐시
* 한 번 조사한 결과는 ARP 캐시라는 메모리 영역에 보존하여 다시 이용한다.
* 우선적으로 ARP 캐시 조사하고, 없으면 ARP 조회를 진행한다.
* ARP 캐시를 이용해 ARP의 패킷은 줄일 수 있으나, 그 값을 계속 사용하면 문제가 생길 수 있다. 
  * ex. IP 주소를 설정해서 고친 경우
* ARP 캐시에 저장된 값은 시간이 지나면 삭제된다 (OS에 따라 다름)

## 6. 이더넷의 기본
> 이더넷은 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술이다.  
> 이더넷도 IP와 마찬가지로 패킷의 내용물은 보지 않는다.

### 이더넷의 원형 (10BASE5)
> 케이블을 통해 신호가 전체에 흐름
* 네트워크의 실체는 케이블만 있다.
* 트랜시버라는 기기도 있으나, 일반 케이블과 유사하게 연결한 케이블 사이에 신호를 흘리는 역할을 한다.
* 한대가 신호를 보내면 연결된 전원이 신호를 받는다.
* 수신처 주소를 통해 해당하는 기기만 패킷을 수신하고 나머지는 폐기한다.

### 리피터 허브를 이용한 파생형 (10BASE-T)
> 신호가 리피터 허브에서 흩뿌려져서 전체에 전달됨
* 트렁크 케이블이 리피터 허브로, 트랜시버 케이블이 트위스트 페어 케이블로 바뀜
* 여전히 신호가 전원에게 전달됨

### 스위칭 허브를 이용한 형태
> 스위칭 허브는 수신처 MAC 주소에 따라 목적지를 확인하고 패킷을 중계하기 때문에 신호는 원하는 상대에게만 흐름
* 스위칭 허브를 사용
* 현재의 이더넷의 형태
* 전원에게 신호가 전달되지 않고, 수신처 MAC 주소로 나타내는 기기가 존재하는 부분에만 신호가 흐름


## 7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다.
> IP가 만든 패킷은 메모리에 기억된 디지털 데이터 이다.  
> 디지털 데이터를 네트워크 케이블에 송출하기 위해서는 전기나 빛의 신호로 변환해야 한다.  

### LAN 어댑터

* 변환 작업을 실행하는 것은 LAN 어댑터이다.  
* LAN 어댑터를 제어하기 위해 LAN 드라이버 소프트웨어가 필요하다(하드웨어의 공통적인 사항).
* LAN 드라이버는 LAN 어댑터 제조 업체 전용 제품을 사용해야 한다.

* LAN 어댑터는 초기화 작업 후 사용할 수 있다. 
  * LAN 드라이버가 하드웨어 초기화 작업을 수행해야 가능
  * 하드웨어 이상 검사, 초기 설정 등의 작업이 수행된다(하드웨어 공통).
  * MAC 회로에 MAC 주소를 설정한다(이더넷 특유 작업).


### MAC 주소 설정

* LAN 어댑터의 ROM에 MAC 주소를 제조할 때 기록하므로, 이 것을 읽어와 설정한다.
  * 이 때 MAC 주소는 중복되지 않도록 일원화 해서 관리한다.  
  * 이렇게 할당된 MAC 주소를 자체적으로 알수도 있지만, 명령이나 설정파일에서 받아 설정하는 경우도 있다.
  * 이 때, LAN 어댑터의 ROM에 기록한 것은 무시한다.  


## 8. 패킷에 3개의 제어용 데이터를 추가한다.
> LAN 드라이버는 IP 담당 부분에서 패킷을 받으면 LAN 어댑터의 버퍼 메모리에 복사한다.  
> 이후에는 MAC 회로에 명령을 보내고, MAC 회로에서 작업이 시작된다.

### 제어용 데이터
* MAC 회로는 송신 패킷을 버퍼 메모리에서 추출한다.  
* 패킷의 앞쪽(왼쪽)에 `프리앰블` 과 `스타트 프레임 딜리미터` 데이터를 부가하고, 뒤쪽(오른쪽)에는 `프레임 체크 시퀀스(FCS)`를 부가한다.
* FCS: 오류 검출용 데이터
* 프리앰블
  * 송신하는 패킷을 읽을 때 타이밍을 잡기 위해 사용
  * 1과 0이 번갈아 나타나는 비트열이 56비트 이어진 것.  
  * 1010 비트 패턴을 신호로 바꾸면 일정한 형태의 파형이 나타남
  * 수신측은 신호를 수신할 때 이 파형에서 타이밍을 판단하며, 1비트 분 신호의 중앙 위치를 판단한다.
* 스타트 프레임 딜리미터
  * 끝이 11이라는 비트 패턴
  * 이로 인해 파형이 변함
  * 패킷의 개시 위치로 간주한다.



### 클록
> 디지털 데이터를 전기 신호로 나타낼 때는 0과 1의 비트 값을 전압이나 전류의 값에 대응시킨다.  
> 각 비트의 구분이 어디까지인지 판단하면서 전압 또는 전류의 값을 읽어야 함
> 그런데 만약 1과 0이 이어지면 신호 변화가 없어지는데 비트를 구분할 수 있을까?

* 이 때 사용할 수 있는 쉬운 방법은 데이터를 나타내는 신호와 별도로 비트 구분을 나타내는 **클록 신호**를 보내는 것이다.
* 클록 신호가 **아래에서 위로 변화할 때** 데이터 신호의 전압과 전류를 읽고 0과 1로 대응 시킨다.
* 하지만 거리가 멀어져서 케이블이 길어지면 신호선의 길이가 달라져서 **데이터 신호와 클록 신호가 전달되는 시간 차**가 발생되는 문제
* cf. 클록 신호: 일정 주기로 결정된 모습으로 변화하는 신호

### 클록 신호 + 데이터 신호
> 데이터 신호와 클록 신호를 합성하여 한 개의 신호로 만들어 위 문제를 해결 가능

* 클록 신호와 데이터 신호를 합성한 신호에서 전압을 결정하는 방법은 특정 표에 따른다 (교재표 참고).
* 송신 측에서 수신측으로 전압을 결정하는 특정 표를 보낸다.

### 프리앰블의 역할
* 클록 신호의 타이밍을 판단하는 것은 중요하다.
* 클록 신호의 타이밍을 잡기 위한 특별한 신호를 패킷 앞에 부가하는데, 이 것이 프리앰블의 역할이다.

### 스타트 프레임 딜리미터
* 스타트 프레임 딜리미터는 패킷의 시작을 나타내며, 수신측은 이를 통해 데이터를 추출한다.  

### FCS
> 패킷을 운반하는 도중에 잡음 등의 영향으로 파형이 흐트러져 데이터가 변한 경우에 검출하기 위해 사용  

* 32비트의 비트열
* 패킷의 맨 앞부분 ~ 맨 끝까지의 내용을 특정 계산식에 기초하여 계산한 것
* CRC라는 디스크 장치 등에 사용하는 오류 검사 코드와 같은 종류
* 패킷 운반 도중 데이터가 변하면 수신측에서 계산한 FCS가 송신할 때 계산한 것과 다른 값이 된다. 
* 이 불일치를 통해 데이터 변질 사실을 검출함


## 9. 허브를 향해 패킷을 송신한다.
> 리피터 허브를 사용할 때는 반이중 모드, 스위칭 허브를 사용할 때는 전이중 모드를 사용한다. 

### 반이중 모드
> 신호의 충돌을 피하기 위한 동작들을 살펴보자  
* 케이블에 다른 기기가 송신한 신호가 흐르는지 조사
* 신호가 흐르고 있다면 기다림(충돌 방지)
* 신호가 정지하거나 원래 흐르지 않고 있었다면 송신 시작
* 송신 동작
  * MAC 회로가 프리앰블의 맨 앞부터 1비트씩 디지털 데이터를 전기 신호로 변환
  * 변환된 신호를 송수신 신호 부분(PHY나 MAU)에 보낸다.
  * 디지털 데이터를 신호로 변환하는 속도 = 전송 속도
  * PHY(MAU) 회로는 신호를 케이블에 송출하는 형식으로 변환 후 송신함


* 이 때 MAC 회로는 공통의 형식 신호를 PHY 회로에 보낸다
  * 이더넷은 케이블의 종류, 전송 속도에 따라 다양한 신호 형식이 규정되어 있음
  * MAC 회로는 형식의 차이에서 벗어나 어느 형식으로도 변환할 수 있는 공통 형식 사용

* PHY(MAU) 회로는 신호를 케이블에 송출하는 형식으로 변환 후 송신함
  * PHY: MAC 회로가 송신한 신호의 형식을 변환하는 변환 회로
  * 수신 신호선에서 신호가 흘러들어오는지도 감시하는 역할


* 신호 송신을 완료할 때까지 수신 신호가 들어오지 않으면 완료
* 이더넷은 송신 신호가 상대에게 완전하게 도착했는지 확인하지 않는다.
* 오류가 발생하면 프로토콜 스택의 TCP가 검출함


* 충돌
  * 신호를 송신하고 있는 사이, 수신 신호가 흘러들어오는 경우가 있다.  
  * 반이중 모드에서 이러한 상황이 발생하면 **신호가 뒤섞여 분간할 수 없는 상태**인 **충돌**이 발생한다.
  * 이 경우 송신을 중지
  * 충돌이 일어난 사실을 알리는 재밍 신호를 흘림
  * 기다렸다가 다시 송신 시도
  * 대기 시간이 중복되지 않도록 고안되어있음(MAC 주소를 바탕으로 난수 생성 후 대기 시간 계산)


* 이더넷이 혼잡해지면 충돌의 가능성이 높아짐
  * 또 다시 충돌이 나면 대기시간이 2배로 늘어남(충돌이 발생할 때마다 2배씩 대기시간 증가)
  * 10번 다시 보내도 해결 안되면 오류로 판단


### 반이중 모드
* 송신과 수신을 동시에 실행해도 충돌 일어나지 않음
* 자세한 건 3장에서 설명합니당~


## 10. 돌아온 패킷을 받는다.
> 리피터 허브를 이용한 반이중 동작의 이더넷은 누군가 신호를 보내면 전체의 수신 신호선에 흘러들어온다.  
> 수신은 신호를 받는 것 부터 시작!  

### 신호 수신
* 프리앰블, 스타트 프레임 딜리미터를 거쳐 디지털 데이터로 변환하는 동작을 개시
* 변환 동작은 송신과 반대로 PHY 회로에서 MAC 회로 방향으로 진행
  * 공통 형식 신호로 변환
  * 디지털 데이터로 변환하여 버퍼 메모리에 저장
* FCS 검사 진행
  * 처음부터 계산한 FCS와 가장 끝에 위치한 FCS 값을 비교(일치하는지)
  * 오류 패킷으로 간주되면 폐기
* MAC 헤더 수신처 MAC 주소와 LAN 어댑터의 MAC 주소 비교
* 나에게 보낸게 아니면 폐기, 맞으면 받아서 버퍼 메모리에 저장
* 할 일 끝나면 패킷을 수신한 사실을 컴퓨터 본체에 통지

### 인터럽트 구조
> 패킷을 수신한 사실을 컴퓨터 본체에 통지할 때는 인터럽트 구조를 사용한다.  
> LAN 어댑터에서 알리지 않으면 컴퓨터 본체는 패킷이 도착한걸 모른다.   
> 이 때 컴퓨터 본체가 실행하고 있는 작업에 끼어들어 LAN 어댑터쪽에 주의를 시키는 것이 인터럽트이다.  


### 인터럽트 동작 
* LAN 어댑터가 확장 버스 슬로 부분에 있는 인터럽트용 신호선에 신호 송신
* 신호선은 인터럽트 컨트롤러를 통해 CPU와 연결되어 있다.
* 신호가 흘러오면 CPU는 실행하던 작업을 보류하고 OS 내부의 인터럽트 처리용 프로그램으로 전환한다.
* LAN 드라이버가 호출되어 LAN 어댑터를 제어하면서 송수신 동작을 실행한다.

### 인터럽트 번호
* 인터럽트에는 번호가 할당되어 있으며, LAN 어댑터를 설치할 때 번호를 하드웨어로 설정한다.
* 인터럽트 처리용 프로그램에는 하드웨어의 인터럽트 번호에 대응하도록 드라이버 소프트웨어를 등록하게 되어 있다.  
* 현재는 PnP(Plug and Play) 사양에 따라 번호를 자동으로 설정

### 인터럽트 이후
* 인터럽트에 의해 LAN 드라이버 동작
* LAN 어댑터의 버퍼 메모리에서 패킷 추출
* LAN 드라이버는 MAC 헤더의 타입 필드 값에서 프로토콜 판별 (예: TCP/IP)
* 타입 필드의 값에 대응하는 프로토콜 스택에 패킷 전달
* 프로토콜 스택이 대응하는 애플리케이션을 판단하여 적절한 조치를 취함


## 11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다. 
> IP 담당 부분은 IP 헤더를 통해 수신처 IP를 조사한다.   
> 수신처 IP 주소와 수신한 LAN 어댑터에 할당된 주소가 일치는지 확인하고 패킷 수신  

### ICMP
이 때, 만약 수신처 IP 주소가 다르다면 오류가 있는 것이다.  
이러한 경우 IP 담당 부분이 **ICMP**라는 메세지를 통신 상대에게 보내 오류를 통지한다.  
ICMP에는 여러 타입의 메세지가 정의되어 있다.  


### 리어셈블링
> IP 프로토콜에는 조각 나누기(fragmentation)라는 기능이 있다.   
> 패킷 운반 도중 짧은 패킷만 다룰 수 있는 통신 회선과 LAN이 있다.   
> 이 때, 패킷을 여러 개로 분할 하는 경우가 있다.  
> 수신한 패킷이 분할된 것이면 IP 담당 부분은 이를 되돌린다.  

* 분할된 패킷은 IP 헤더에 있는 플래그라는 항목을 보면 알 수 있다.  
* 수신 패킷이 분할된 것이라면 IP 담당 부분 내부 메모리에 일시적으로 보관한다.
* 분할된 IP 헤더에 있는 ID 정보의 값이 모두 같아 이를 참조해 다른 패킷을 기다린다.
* 프래그먼트 오프셋(fragment offset)에는 패킷이 원래 패킷의 위치 정보가 들어있다.
* 분할된 패킷이 모두 도착하면 리어셈블링을 진행한다.
  * 패킷을 원래 모습으로 되돌리는 동작

### 리어셈블링 이후
* 리어셈블링이 끝나면 패킷을 TCP 담당부분에 건내준다.
* IP 헤더에 기록된 수신처 IP, 송신처 IP, TCP 헤더에 기록된 수신처 포트 번호, 송신처 포트 번호를 조사해서 해당하는 소켓을 찾는다.  
* 해당 소켓을 찾은 후에는 통신 진행 상태 기록을 기반으로 상황에 따라 적절한 동작을 실행한다.  



