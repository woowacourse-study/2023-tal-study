CHAPER 1-2 질문

1. 1단원-2. 1번의, **다시 서브넷의 허브가 라우터까지 메시지를 보낸다?????????**
2. 1단원-1. 5번의, 3번 : **실제로는 리졸버 호출 시 지정한 메모리 영역에 IP 주소를 저장한다?????? = ip주소를 캐싱해서 쓴다는 말인가요??**
3. 1단원-2. 2번의 계층화된 도메인의 정보를 서버에 등록할 때, **하나의 도메인을 일괄적으로 취급한다는 말이 뭐임?????**

---

# 1단원 : **웹 브라우저가 메시지를 만든다**

## (1)

## (2) 웹서버의 IP 주소를 DNS 서버에 조회한다

1. ip 주소의 기본
    - 사내 lan은 TCP/IP 개념에 기초하여 만들어져있다.
    - TIC/IP **서브넷**이라는 작은 네트워크를 **라우터**로 접속하여 전체 네트워크가 만들어진다.

      **내 이해 :**

        - 즉 큰 네트워크에서 작은 네트워크(서브넷)으로 연결할 때도 라우터 사용
        - 작은 네트워크에서 큰 네트워크 나갈 때도 라우터를 사용한다
    - 서브넷에 접속되어 있는 각 컴퓨터의 호스트 주소를 ip주소라고한다.
    - 데이터 이동 경로
        1. 누군가 보낸 메시지를 **서브넷 내의 허브가 운반**한다.
        2. 누군가 에게 **가장 가까운 라우터까지 이동 및 도착**한다.
        3. 라우터는 메시지를 보낼 상대를 확인하여 다음 라우터를 판단하고 그곳으로 보내도록 지시한다.

           **내 질문 : 라우터란? 라우팅 경로는 어떻게?**

            - 라우터는 네트워크의 트래픽을 관리하고, 다른 네트워크로 라우팅하는 역할을 한다.
            - 라우팅 테이블에는 **네트워크 대역별로 어느 인터페이스로 패킷을 보낼 지**에 대한 정보가 저장됩니다.
                - 인터페이스란? : 라우터의 인터페이스로, 네트워크 장비에서 다른 네트워크 또는 장비와 연결되는 접속 지점
                - 라우터가 여러 개의 네트워크를 연결하는 경우, 각 네트워크와 연결된 인터페이스가 있습니다. 예를 들어, **하나의 인터페이스는 로컬 네트워크에 연결되고, 다른 인터페이스는 외부 인터넷에 연결**될 수 있습니다. 이렇게 인터페이스들은 네트워크 간의 연결을 담당하며, 라우팅 테이블은 이러한 인터페이스들을 통해 데이터를 어떻게 전송할지 결정합니다.
                1. **가장 적합한 경로 선택:** 라우팅 테이블에서 목적지 **IP 주소와 일치하는 가장 가까운 네트워크 대역** 및 해당 경로 정보를 찾습니다. 이 **경로는 패킷이 전송될 다음 홉(라우터 또는 게이트웨이)의 IP 주소**입니다.
                2. **다음 홉으로 패킷 전송:** 선택된 다음 홉의 IP 주소를 사용하여 데이터 패킷을 해당 홉으로 전송합니다.
                3. **전송 및 라우팅 연속:** 패킷은 계속해서 목적지로 향하면서 라우팅 테이블을 기반으로 다음 홉을 선택하고 전송됩니다.

                   라우팅 경로는 결정되는 요인에는 네트워크 구조, 라우팅 프로토콜, 라우터 간의 거리 및 비용, 라우팅 정책 등이 포함. 라우팅 테이블은 네트워크 관리자가 설정하며, 라우터들 사이에서 라우팅 정보를 교환하고 업데이트하는 라우팅 프로토콜에 따라 동적으로 변경될 수도 있습니다.

        4. **다시 서브넷의 허브가 라우터까지 메시지를 보낸다?????????**

2. 도메인명과 IP 주소를 구분하여 사용하는 이유


3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다
    - url의 IP 주소를 찾는 법
      = 가장 가까운 DNS 서버에, URL에 해당하는 서버의 IP 주소를 묻는다.
    - 브라우저가 IP 주소를 조회할 수 있는 이유는 소켓 라이브러리에 **DNS 리졸버**가 있기 때문이다.
    - **소켓 라이브러리**는 **OS의 네트워크 기능을 어플리케이션에서 호출하기 위한** 부품(프로그램)들을 모아둔 것이다.
    - DNS 리졸버는 DNS 서버에 대한 클라이언트로서, IP 주소를 조사하는 **네임 리졸루션**을 실행한다.

4. 리졸버를 이용해 DNS 서버에 IP 주소를 조회한다
    - 어플리케이션인 **브라우저**에서 소켓 라이브러리(os 기능을 어플리케이션에서 사용하게 하기 위한 프로그램 모음)의 DNS 리졸버는 호출.

      : 코드 상에서 리졸버의 **프로그램명과 도메인명(웹 서버의 이름)**을 쓰기만 하면 호출할 수 있다.

    - 브라우저는 리졸버를 통해 알아낸 IP주소를 추출, HTTP 요청 메시지와 함께 OS에 건네주며 **송신을 의뢰**.

5. 리졸버 내부의 작동
    - 리졸버를 호출하는 코드를 실행하면 어플리케이션(브라우저)의 동작은 일시적으로 정지하고 리졸버가 실행.
    1. 리졸버에서는 DNS 서버에 IP주소를 문의하기 위한 **메시지를 만들고**
    2. **메시지의 송수신**은 OS 내부의 **프로토콜 스택을 호출하여 실행을 의뢰**한다.

       프로토콜 스택 → **LAN 어댑터를 통해 메시지가 송신**된다..

       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/932ab380-a6c8-4c8b-84dc-c9583fcfb280/Untitled.png)

    3. 리졸버는 프로토콜 스택을 경유해 받은 DNS서버로부터 받은 응답 내용을 해독하고, IP 주소를 추출해 브라우저에게 전달한다.
        - **실제로는 리졸버 호출 시 지정한 메모리 영역에 IP 주소를 저장한다??????**
    4. 제어가 브라우저로 다시 돌아온다.

   ### DNS 서버의 IP 주소는 어떻게 알까?

   : 이는 컴퓨터의 TCP/IP 설정 항목에 미리 설정되어있다.


## (3) 전 세계의 DNS 서버가 연대한다.

1. DNS 서버의 기본 동작
    - 클라이언트의 조회 메시지를 받고, 조회 내용에 응답
    - 조회 메시지
        1. 이름: 서버 또는 메일의 목적지
        2. 클래스 : 현재는 인터넷 이외의 네트워크는 소멸되어 IN(인터넷)만 지원한다
        3. 타입 : 이름에 어떤 타입 정보가 지원되는지 확인
            1.  A : Address = ip 주소 조회할 때 사용
            2. MX : MailExchange = 메일 목적지 조회할 때 사용)
            3. PTR : IP 주소에서 이름을 조사할 때 사용
            4. CNAME : 이름에 닉네임을 붙이기 위해 사용
            5. NS : DNS 서버의 IP 주소를 등록
            6. SOA: 도메인 자체 속성 정보 등록
    - 리소스 레코드

      1건의 도메인 등록 정보

      | 이름 | 클래스 | 타입 | 회답 항목 |
              | --- | --- | --- | --- |
      | http://www.lab.cyber.co.kr/ | IN | A | 192.0.2.226 |
    - DNS 서버에 `A` 타입으로 등록하면 웹 서버의 이름으로 사용할 수 있고, 원하는 이름을 사용할 수 있다.
    - `MX` 타입인 경우 , 메일 서버의 `우선 순위`와 `메일 서버의 이름`, 메일 서버의 IP 주소 회답.

      우선순위란, 메일 배송 목적지로 복수의 메일 서버가 등록된 경우, 어느 메일 서버를 우선 선택해야하는지 판단하기 위함. 작은값인 메일서버를 우선.

2. 도메인의 계층
    - 호스트 수가 제한되어 있으면, 한대의 dns서버에 등록하면 되지만, 인터넷에는 많은 수의 호스트가 있다. 따라서, 정보를 분산시켜 다수의 dns서버에 **등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조**를 이룬다.
        - 도메인이란?
            - `.` 으로 계층을 구분하며, 구분된 하나하나를 **도메인**
            - 계층화된 도메인의 정보를 서버에 등록할 때, **하나의 도메인을 일괄적으로 취급**
            - 도메인 아래에 하위 도메인을 생성할 수 있는데, 이를 **서브 도메인**.

              예시)

                - 메인 도메인: `example.co.kr`
                - 서브 도메인: `sub.example.co.kr`

3. 담당 DNS 서버를 찾아 IP 주소를 가져온다.
    - 먼저 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록하고, 상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록하는 식으로 차례대로 등록

      예시)

        - `com` 도메인의 DNS 서버
            - `glasscom.com` 의 DNS 서버 도메인을 등록
        - `glasscom.com` 의 DNS 서버
            - `lab.glasscom.com` 의 DNS 서버 도메인을 등록
    - (웹서버가 등록된) dns 서버를 찾아 ip 주소를 가져온다

      ### 최상위 도메인과 루트 도메인(최상위 도메인의 상위개념)

        - `com` 이 최상위 도메인
        - 루트 도메인은 최상위 도메인의 상위 개념으로, 일반적으로는 생략한다. **끝에 마침표**를 찍어서 나타낼 수 있다.
        - **루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록**하여 **모든 DNS 서버가 루트 도메인에 액세스** 할 수 있다.
            - 루트 도메인의 DNS 서버 IP 주소는 전 세계에 13개 밖에 없고, 잘 변경되지 않는다.
        - **DNS 서버 소프트웨어를 설치하면 자동으로 루트 도메인의 DNS 서버 정보가 등록된다**.

      ### DNS 서버 찾기

        - 클라이언트의 **가장 가까이에 있는 DNS 서버**에 웹 서버(`www.naver.com`)에 관한 정보를 조회한다.

          (**클라이언트의 TCP/IP 설정 항목의 DNS 서버로 설정되어 있는 DNS 서버**)

        - 가장 가까운 DNS 서버(이하 A 서버)에 `www.naver.com` 가 등록되어 있지 않으면, A 서버가 루트 도메인 DNS 서버에 조회메세지를 전송한다.
        - 루트 도메인 DNS 서버에 `com` 가 등록되어 있으므로 `com` 의 DNS 서버 IP 주소를 반송한다.
        - `naver.com` 에서도 같은 과정을 반복한다.
        - `www` 에 도달하면 클라이언트에 회답할 항목을 받는다.

          참고 사항: 현실에서는 **한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있다. 그렇기 때문에 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도 있다.**


4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.
    - DNS 서버는 한 번 조사한 이름을 캐시에 기록한다.
    - 조회한 이름이 도메인에 등록되어 있지 않은 경우에는 이름이 존재하지 않는다는 회답이 돌아오지만, 이 역시 캐시에 기록할 수 있다.
    - **캐시에 정보를 저장한 후 등록 정보가 변경되는 경우** 주의 해야한다.

      ⇒ 그렇기 때문에 **DNS 등록하는 정보에는 유효기한을 설정하고, 지나면 캐시에서 삭제**한다.

    - 조회에 회답할 때, 정보가 캐시에 저장된 것인지 등록처 DNS 서버에서 회답한 것인지 알려준다.
    - **캐시: 한 번 사용한 데이터를 “데이터의 이용 장소와 가까운 곳에 잇는 고속의 기억 장치에 저장”하여 두 번째 이후의 이용을 고속화하는 기술**


## (4) 프로토콜 스택에 메시지 송신을 의뢰한다

- 애플리케이션은 해당 스택의 디지털데이터를 송신하기 위해 소켓 라이브러리 사용 → 프로토콜 스택에 의뢰
- 소켓은 데이터의 출입구이다
- 데이터 송수신 이전 과정 : 서버에서 소켓 생성 - 클라이언트 소켓 생성 및 서버 소켓으로 파이프 연결 → 데이터 송수신 시작
- 데이터 송수신 이후 과정 : 파이프 분리되면 소켓 말소하여 통신 동작 종료된다

클라이언트의 어플리케이션이 프로토콜 스택에 데이터 송수신 의뢰하는 과정

1. 소켓 작성
    - 소켓 라이브러리의 소켓 호출 = 소켓 생성
    - 소켓 생성시 디스크립터 반환 및 디스크립터(소켓 번호표)는 메모리에 기록
    - 디스크립터가 필요한 이유
        - 복수의 데이터 송수신 동작이 동시에 진행되는 경우, 어떤 애플리케이션+데이터 송수신 요청의 소켓인지 식별하는 것
        - 소켓 생성 이후, 소켓으로 파이프 연결하고 데이터 송수신 할 때, 프로토콜 스택이 어떤 소켓 사용할지 판단하는 기준이 되는 것
2. 파이프 연결
    - 소켓 라이브러리의 커넥트 호출
        1. 커넥트 → 프로토콜 스택에 디스크립터(소켓의 식별자) 통지
        2. **프로토콜스택이 받은 디스크립터로 식별한 소켓을 가지고 파이프 연결을 진행**
    - 연결 시, 포트번호로 서버의 어떤 소켓에 접속할지 판단.
    - 연결 시, 서버가 클라이언트의 어떤 소켓에 접속할지는, 클라이언트가 자신의 소켓 포트번호를 통지한다.
3. 데이터 송신
    - 요청 데이터 생성 및 **요청 버퍼링(브라우저 내부의 요청 버퍼에 저장된다)**
    - 소켓 생성 및 연결 = 목적지 ip주소와 포트번호를 사용하여 소켓 생성하고 연결 수립
    - **소켓 라이브러리의 Write 호출해 요청 버퍼 데이터를 서버로 전송**
        1. 디스크립터(어떤 소켓 쓸 건지)로 소켓 선택해서
        2. 송신 데이터를 애플리케이션의 버퍼에서 소켓 버퍼로 복사한다.
        3. 소켓 버퍼에 저장된 데이터들은 일시적으로 머무르다가, **소켓라이브러리가 프로토콜 스택에 데이터 전달해야 함을 알림**
        4. **프로토콜 스택은 주기적으로 소켓 버퍼 내에 저장된 데이터 확인** (네트워크 계층으로 전송해야하는 데이터)하고 소켓 버퍼의 데이터를 읽어서 패킷으로 변환(캡슐화)한다.
        5. 프로토콜 스택을 통해 서버 측으로 데이터 전송(데이터가 네트워크 계층으로 전달 됨)
4. 데이터 수신
    1. 데이터가 추출되고, 프로토콜 스택이 해당 데이터를 해당 소켓의 소켓 버퍼로 전송한다
    2. 데이터가 소켓 버퍼로 전달되면, 프로토콜 스택은 응용 계층에 데이터를 읽으라는 알림을 보낸다.
    3. 애플리케이션이 소켓 라이브러리의 Read함수 사용하여, 소켓 버퍼에서 데이터를 읽어온다
5. 연결 끊기 및 송수신 종료
    - 클라이언트에서 연결 끊기 및 송수신 종료
        1. 브라우저가 데이터 수신을 완료하면
        2. 소켓 라이브러리의 close 호출
        3. 프로토콜 스택에 연결 끊기 동작을 의뢰
        4. 소켓 사이 연결한 파이프 분리 및 소켓 말소됨
    - 또는, 메시지 송신 완료 후 연결
