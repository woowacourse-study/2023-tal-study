#  Chapter 02 Summary 

## 소켓 작성
> 애플리케이션의 의뢰로 프로토콜 스택이 TCP 프로토콜을 이용해서 메세지를 송신한다.  

### 프로토콜 스택 내부 구성
> 네트워크 애플리케이션이 데이터 송수신 의뢰  
- 프로토콜 스택 (상단)이 TCP(또는 UDP) 프로토콜을 사용해 데이터 송수신 담당 (실행)
- 프로토콜 스택 (하단)에서 IP 프로토콜을 사용해 패킷 송수신 동작 제어

### 소켓의 실체
> 프로토콜 스택은 내부에 통신 동작을 제어하기 위해, 제어 정보를 기록하는 메모리 영역을 가진다.  
> 이 제어 정보(통신 상대의 IP 주소, 포트 번호 등)가 소켓의 실체이다.  
> 즉, `소켓의 실체는 제어 정보를 기록한 메모리 영역`이다.  

- `netstat` 명령어를 통해 소켓의 내용을 확인할 수 있다 (제어 정보 확인)  

### 소켓 호출 시 프로토콜 스택의 동작
1. 소켓 생성: 초기 제어 정보 기록
2. 소켓 식별 정보 전달: 디스크립터를 애플리케이션에 알린다.
3. 디스크립터 통지: 애플리케이션은 데이터 송수신 시 디스크립터를 통지한다.  


## 서버 접속  
> 클라이언트측 소켓 → 서버측 소켓에 접속하는 단계  

### 접속
- 클라이언트
    - 소켓 작성 후 `connect` 호출: 프로토콜 스택이 자기쪽의 소켓을 서버측 소켓에 접속(**제어 정보 교환**을 통해 필요한 정보 기록, 데이터 송수신이 가능한 상태로 만듦)  
    - 케이블은 항상 접속된 상태에 있으므로 언제든 신호 보낼 수 있음
    - 소켓을 만든 직후, 통신상대가 누구인지 모르기 때문에 **서버의 ip주소나 포트번호를 프로토콜 스택에 알리는 동작이 필요**


- 서버
    - 클라이언트에서 제공한 제어 정보를 통해 **프로토콜 스택이 클라이언트 정보를 가짐**  


- 접속 동작
    - 통신 상대와의 사이에서 제어 정보 주고받고 소켓에 기록 (송수신 가능 상태)  
    - 송 수신 데이터를 일시적으로 저장하는 메모리(버퍼 메모리) 영역 확보

### 패킷의 헤더
> 제어 정보는 패킷의 헤더의 형태로 주고 받는다.  

- 통신 동작에서 사용되는 제어 정보는 2가지 이다.  
  - 헤더에 기입되는 정보  
  - 소켓에 기록되는 정보

### 접속 동작의 실체
> 접속 동작의 실체는 소켓 라이브러리의 `connect`를 호출하는 것이다.  
> `connect`의 형태: `connect(<디스크립터>, <서버측 IP 주소와 포트 번호>, ...)`  
> 서버측 정보가 프로토콜 스택의 TCP 담당부분에 전달되어 서버의 TCP 담당 부분과 제어 정보를 주고 받는다.  


### 접속 과정
1. TCP 담당 부분이 TCP 헤더 생성 후 IP 담당부분에 송신 의뢰
   - 접속 시작을 나타내는 제어 정보 기록
   - SYN 컨트롤 비트를 1로 만듦
   - 송수신처 소켓 지정

2. IP 담당 부분이 패킷 송신 동작 실행
3. 서버의 IP 담당 부분이 TCP 담당 부분에 패킷 전달  
4. 서버측 TCP 담당 부분이 수신처 포트 번호에 해당하는 소켓을 찾아 정보를 기록
5. 서버의 TCP 담당 부분이 응답을 돌려보냄
    - TCP 헤더 생성 (ACK 컨트롤 비트 1로 만들어 수신을 알림)
    - IP 담당 부분에 송신 의뢰
6. 클라이언트 TCP 담당 부분이 TCP 헤더를 조사해서 접속 여부 확인 (SYN이 1이면 성공)  
7. 소켓에 서버 IP 주소, 포트 번호 등 소켓 접속 완료를 나타내는 제어 정보 기록
8 서버에 TCP 헤더 생성해서 보냄 (ACK가 1)

## 데이터 송수신
> 프로토콜 스택은 애플리케이션이 의뢰한 데이터를 분할해서 서버에 송신한다.  
> 애플리케이션이 `write` 호출하여 프로토콜 스택에 송신 데이터 전달하면 프로토콜 스택이 송신 동작을 시작한다.  

### 프로토콜 스택의 동작 기준
> 프로토콜 스택은 데이터를 받으면 송신용 버퍼 메모리에 저장하고, 다음 데이터를 기다린다.  
> 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 프로토콜 스택에서 제어할 수 없다.  
> 프로토콜 스택의 데이터 저장 및 송신의 판단 요소는 2가지 이다.  

1. 한 패킷에 저장할 수 있는 데이터의 크기: MTU를 매개변수로 받아 판단   
2. 타이밍: 내부에 타이머를 두고 일정 시간이 경과하면 데이터가 다 모이지 않아도 송신  

판단 방법은 OS 종류나 버전에 따라 달라짐  

### 데이터가 클 때는 분할하여 보낸다
> 송신 버퍼의 데이터가 MSS를 초과하면 분할하고, 하나씩 송신한다. 

### ACK 번호를 사용하여 수신 확인
> TCP에는 상대가 패킷을 잘 수신했는지 확인하고, 실패하면 다시 송신하는 기능이 있음  
> 시퀀스 번호와 ACK 번호를 이용해 수신을 확인한다.  

- 시퀀스 번호: 분할 조각이 몇 번째 바이트에 해당하는지 기록
- ACK 번호: 이전에 수신한 데이터까지 합쳐서 몇번째 바이트까지 수신한건지 나타냄 (패킷 누락 확인 가능)


- 접속 동작 시: 클라이언트는 데이터의 초기 값 산출하여 서버에 통지하고, 서버는 초기 값을 기반으로 ACK 번호와 시퀀스 초기값을 클라이언트에 통지
- 송수신 동작 시: 클라이언트에서 초기값으로부터 ACK번호 산출하여 서버에 반송 → 클라이언트에서 서버로 데이터와 함께 시퀀스 번호 전송 → 서버에서 ACK 번호 반송

### ACK 번호 대기 시간 조정
> TCP 는 타임 아웃 값을 동적으로 변경하는 방법을 사용한다.  
> 데이터 송신 동작 시 항상 ACK 번호가 돌아오는 시간을 계측하며, 그에 따라 대기 시간도 바꿔 설정한다.  

### 윈도우 제어 방식
>  ACK 번호를 기다리는 사이에 다음 송신을 진행하는 방식이다.  
> ACK 번호를 기다리는 시간 낭비를 줄이기 위해 TCP는 윈도우 제어 방식을 사용한다.  

- 수신 측에서 송신 측에 수신 가능한 데이터 양을 통지한다(윈도우 필드, 윈도우 사이즈).
- 윈도우 통지와 ACK 번호 통지 타이밍이 다르기 때문에 두 패킷을 따로 보내면 송신하는 패킷의 수가 많아져 효율성이 저하된다.
  - ACK 번호와 윈도우 통지를 하나의 패킷에 합승시켜 통지한다.  

### HTTP 응답 메세지 수신   
- 브라우저는 서버에서 돌아오는 응답 메세지를 받기 위해 read 프로그램을 호출
- 프로토콜 스택은 응답 메시지 패킷이 도착할 때까지 대기
- 패킷을 수신하면 수신 버퍼에서 수신 데이터 추출
- 추출 데이터를 애플리케이션에 전달

## 연결 끊기와 소켓 말소

### 연결 끊기
> 데이터를 모두 송신하면 송수신을 종료한다.  

#### 서버측
- 애플리케이션이 먼저 Socket 라이브러리의 close를 호출한다.
- 프로토콜 스택이 TCP 헤더를 만들고, 연결 끊기를 나타내는 정보를 설정한다.
- 컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해달라고 한다.
- 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다.

#### 클라이언트측
- 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면, 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록한다.
- 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송하고, 이 것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다린다.
- 애플리케이션이 read를 호출하여 데이터를 가지러온다.
- 데이터를 건네지 않고, 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트측의 애플리케이션에게 알린다.
(이전에 수신한 데이터가 수신 버퍼에 남아있으면 애플리케이션에 전달)
- 웹의 동작은 서버가 응답을 반송하면 끝나도록 규칙으로 정해져 있으므로 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료한다.
- 애플리케이션이 close를 호출하여 데이터 송수신 동작을 끝낸다.
- 프로토콜 스택은 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당부분에 의뢰해서 서버에 송신한 후 서버에서 ACK 번호가 돌아오면 서버와의 대화가 끝난다.

### 소켓 말소
> 대화가 끝나도 오작동을 막기 위해 잠시 기다린 후 소켓을 말소한다.  
> 패킷이 없어졌을 때, 다시 보내기 동작은 반복되다가 회복 불가 판단이 나면 동작을 멈춘다.  


### 데이터 송수신 전체 동작 정리

#### 접속
> 데이터 송수신에서 최초의 동작은 소켓을 작성하는 단계이다.

- 서버측에서 애플리케이션이 동작하기 시작했을 때 소켓을 만들고, 접속 대기 상태로 만든다.
- 소켓 작성 단계에서는 패킷이 흐르지 않는다.
- 소켓을 만들면 클라이언트에서 서버를 향해 접속 동작을 살행한다(사용자가 동작하면 패킷 생성).
  - 클라이언트가 SYN을 1로 만든 TCP 헤더를 만들어서 서버로 보낸다.
  (클라이언트가 서버에 데이터를 보낼 때 사용하는 시퀀스 번호의 초기값도 기록)
    - 서버에서 클라이언트에 데이터를 송신할 때 사용하는 윈도우 값도 기록되어 있음
    - 이게 서버에 도착하면 서버에서 SYN을 1로 만든 TCP 헤더(시퀀스 번호, 윈도우, ACK 번호 기록)가 돌아온다.
- 클라이언트에서 서버로 ACK번호를 기록한 TCP헤더를 보낸다.

#### 송수신
- 웹의 경우 클라이언트에서 서버에 리퀘스트 메시지를 보내는 것부터 시작한다.
- TCP는 이 것을 분할하고 TCP 헤더를 맨 앞에 부가해서 서버에 보낸다.
  - TCP 헤더에는 시퀀스 번호(송신 데이터가 몇 번째 바이트부터 시작되는지 나타냄)가 기록되어 있다.
- 서버는 ACK 번호를 반송한다.
- 최초의 데이터라면 서버는 받기만 하고, 이후에는 애플리케이션에 데이터를 넘긴다.
  - 이 때, 수신 버퍼에 빈 영역이 생기고, 이 때 윈도우 값을 기록하여 클라이언트에 통지한다.
- 이렇게 클라이언트에서 서버에 리퀘스트 메시지를 보내면 서버는 응답 메세지를 반송할 것이다.

#### 연결 끊기
- 서버가 응답 메세지를 보내기를 완료하면 연결 끊기 동작에 들어간다.
(웹의 경우 서버에서 먼저 연결 끝기 동작에 들어감)
- FIN을 1로 만든 TCP 헤더가 흐르고, ACK 번호의 TCP 헤더가 돌아온다.
- 역방향으로 FIN을 1로 만든 TCP 헤더와 ACK 번호의 TCP 헤더가 흐른다.
- 잠시 후 소켓이 말소된다.

## IP와 이더넷의 패킷 송수신 동작
> TCP 담당 부분은 각 단계에서 IP 담당 부분에 의뢰하여 데이터를 패킷의 모습으로 만들어 보낸다.
> 패킷은 헤더와 데이터로 구성된다.  

### 패킷 송수신 과정
- 송신처에서 패킷 생성 후 가까운 중계 장치에 송신
- 중계 장치는 패킷의 헤드를 조사 후 목적지 판단
- 다음 중계 장치로 패킷을 보낸다.
- 차례로 패킷을 중계하면 최종적으로 수신처의 기기에 패킷이 도착한다.
- 수신처에서 송신처를 향해 회답 패킷을 보낸다.

### 라우터와 헤더
- 라우터가 목적지를 확인하여 다음 라우터를 나타낸다(IP 규칙에 따라 패킷 운반).
- 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착한다(이더넷 규칙에 따라 패킷 운반).

### MAC 헤더와 IP 헤더 
> MAC 헤더는 이더넷용 헤더이고, IP 헤더는 IP용 헤더이다.  

- 송신처에서 목적지 서버의 IP 주소를 IP 헤더의 수신처에 기록
- 패킷은 허브에 도착: 수신처 정보를 이용해 패킷의 목적지 판단 및 중계
- 패킷은 라우터에 도착: 다음 라우터 조사 및 MAC 주소 조사 후 기록


### IP 헤더 & MAC 헤더  
> IP 헤더에는 다양한 값들이 있고, 그 중 수신처 IP 주소와 송신처 IP 주소도 포함되어있다.    
> MAC 헤더에는 수신처와 송신처의 MAC 주소, 이더 타입 정보가 있다.  

### ARP
> 상대의 MAC 주소를 조사할 때 쓰이는 것이 ARP이다.  
> 이더넷에는 연결되어 있는 전체에게 패킷을 전달하는 브로드캐스트라는 구조가 있다.  
> 이를 이용해 상대가 같은 네트워크에 존재한다면 MAC 주소를 알 수 있다.  

### 이더넷
> 이더넷은 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술이다.  
> 이더넷도 IP와 마찬가지로 패킷의 내용물은 보지 않는다.  

### IP 패킷을 전기나 빛의 신호로 변환하여 송신
> LAN 어댑터가 변환 작업을 실행한다.  
> LAN 어댑터를 제어하기 위해 LAN 드라이버 소프트웨어가 필요  
> LAN 어댑터는 초기화 작업 후 사용

- MAC 주소 설정: LAN 어댑터의 ROM에 MAC 주소를 제조할 때 기록하므로, 이 것을 읽어와 설정한다.  

### 패킷에 3개의 제어용 데이터를 추가 
> 패킷의 앞쪽(왼쪽)에 프리앰블 과 스타트 프레임 딜리미터 데이터를 부가하고, 뒤쪽(오른쪽)에는 프레임 체크 시퀀스(FCS)를 부가한다.

- 데이터 신호와 클록 신호를 합성하여 한 개의 신호로 만들어 거리가 멀어져서 케이블이 길어지면 신호선의 길이가 달라져서 데이터 신호와 클록 신호가 전달되는 시간 차가 발생되는 문제를 해결 가능
- 프리앰블: 클록 신호의 타이밍을 잡기 위한 특별한 신호
- 스타트 프레임 딜리미터: 패킷의 시작을 나타내며, 수신측은 이를 통해 데이터를 추출
- FCS: 패킷을 운반하는 도중에 잡음 등의 영향으로 파형이 흐트러져 데이터가 변한 경우에 검출하기 위해 사용

### 반이중 모드 
> 리피터 허브를 사용할 때는 반이중 모드, 스위칭 허브를 사용할 때는 전이중 모드를 사용한다.  

- 신호를 송신하고 있는 사이, 수신 신호가 흘러들어오는 경우가 있다.
- 반이중 모드에서 이러한 상황이 발생하면 신호가 뒤섞여 분간할 수 없는 상태인 충돌이 발생한다.
- 이 때, 송신을 중지하고 재밍 신호를 흘린 후 다시 송신한다.  
- 이더넷이 혼잡해지면 충돌 가능성이 높아지고 대기시간이 증가한다. 

### 패킷 수신
> 리피터 허브를 이용한 반이중 동작의 이더넷은 누군가 신호를 보내면 전체의 수신 신호선에 흘러들어온다.

#### 신호 수신
- 프리앰블, 스타트 프레임 딜리미터를 거쳐 디지털 데이터로 변환하는 동작을 개시
- 변환 동작은 송신과 반대로 PHY 회로에서 MAC 회로 방향으로 진행
- FCS 검사 진행
- MAC 헤더 수신처 MAC 주소와 LAN 어댑터의 MAC 주소 비교
- 나에게 보낸게 아니면 폐기, 맞으면 받아서 버퍼 메모리에 저장
- 할 일 끝나면 패킷을 수신한 사실을 컴퓨터 본체에 통지

### 인터럽트 구조
> 패킷을 수신한 사실을 컴퓨터 본체에 통지할 때는 인터럽트 구조를 사용한다.

#### 인터럽트 동작
- LAN 어댑터가 확장 버스 슬로 부분에 있는 인터럽트용 신호선에 신호 송신
- 신호가 흘러오면 CPU는 실행하던 작업을 보류하고 OS 내부의 인터럽트 처리용 프로그램으로 전환한다.
- LAN 드라이버가 호출되어 LAN 어댑터를 제어하면서 송수신 동작을 실행한다.

###  서버의 응답 패킷을 IP에서 TCP로 넘기기
> IP 담당 부분은 IP 헤더를 통해 수신처 IP를 조사한다.  
> 수신처 IP 주소와 수신한 LAN 어댑터에 할당된 주소가 일치는지 확인하고 패킷 수신  

#### ICMP
- 만약 수신처 IP 주소가 다르다면 오류가 있는 것이다. 
- 이러한 경우 IP 담당 부분이 ICMP라는 메세지를 통신 상대에게 보내 오류를 통지한다.

#### 리어셈블링
> IP 프로토콜에는 조각 나누기(fragmentation)라는 기능이 있다.
> 패킷 운반 도중 짧은 패킷만 다룰 수 있는 통신 회선과 LAN이 있다.
> 이 때, 패킷을 여러 개로 분할 하는 경우가 있다.
> 수신한 패킷이 분할된 것이면 IP 담당 부분은 이를 되돌린다.




