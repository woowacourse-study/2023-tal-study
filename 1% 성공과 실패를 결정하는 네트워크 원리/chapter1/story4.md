# chapter 1. 웹 브라우저가 메시지를 만든다
## story4. 프로토콜 스택에 메시지 송신을 의뢰한다

- OS의 프로토콜 스택에 의뢰 : 네트워크 애플리케이션은 해당 스택에 디지털 데이터를 송신하도록 의뢰
    - socket라이브러리를 사용함

      : dns 서버에 ip주소 조회할 때도 사용함 (라이브러리의 프로그램 부품을 하나씩 호출하고 끝남)

      : 복수의 부품을 결정된 순번대로 호출해야함 (데이터 송신 동작 전체)


- TCP프로토콜을 사용한 데이터 송-수신 동작
    - 꼭 알아야할 개념
        - 소켓 : 데이터의 출입구
            - 클라이언트(서버) 프로그램 ↔ 프로토콜 스택 사이에 데이터 송 수신
            - 프로토콜 스택 - 네트워크 - 프로토콜 스택 사이에 데이터 송 수신

    - 데이터 송 수신이 실행되기 까지의 과정 : **클라이언트 측 소켓에서 ⇒ 서버측으로 연결**
        1. 서버측에서 소켓(데이터의 출입구)을 만든다
        2. 소켓에 클라이언트가 파이프 연결하기를 기다린다
        3. 서버측이 기다리는 동안, 클라이언트 측에서 파이프를 연결한다(클라이언트도 소켓을 마드로, 소켓이서 파이프를 늘려 서버측의 소켓에 연결한다)
        4. 소켓이 서로 연결되면 데이터 송 수신 동작이 실행된다

    - 데이터 송 수신이 끝난 후의 동작 : 서버/클라이언트 측 분리해도 상관없지만,
      (HTTP 1.0의 경우 서버측에서 클라이언트에 데이터 보내기를 완료하면, 서버측에서 파이프를 분리한다)
        - 데이터를 전부 보내고 나면 파이프가 분리된다.
        - 파이프가 분리되면 소켓을 말소하여 통신 동작이 종료된다.


질문 POINT :그럼 서버측에서 열어두는 소켓은 말소되지 않는 건가? 클라이언트만 파이프 제거되면 소켓도 제거되는 것인가?

- 데이터 송 수신 동작의 4가지 과정에 따라 애플리케이션이 **socket 라이브러리 안의 프로그램 부품(중개인 역할)을 호출**한다 ⇒ 소켓 라이브러리의 프로그램 부품이 프로토콜 스택에 통지한다 ⇒ **프로토콜 스택이 실제 동작을 실행한다**
    1. 소켓 만들기(소켓 작성)
    2. 서버측의 소켓에 파이프를 연결한다(접속)
    3. 데이터를 송수신
    4. 파이프를 분리하고 소켓을 말소한다(연결 끊기)
    
- 즉, 애플리케이션(ex 브라우저)가 직접 데이터 송수신 파이프를 연결하는 것이 아니라, 
⇒ 프로토콜 스택에 의뢰
~~⇒ 프로토콜 스택이 socket 라이브러리 안의 프로그램을 호출해서 파이프를 연결하고, 데이터를 전송한다.~~

## 애플리케이션은 어떻게 프로토콜 스택에 데이터 송수신을 의뢰하는가

### 1) 소켓의 작성

1. 애플리케이션이 소켓라이브러리의 소켓이라는 부품(프로그램)을 호출한다 ⇒ 소켓이 생성된다
   ex. ipv4사용, 스트림형 파이프
2. 소켓 생성 시, **디스크립터(번호표)** 생성되어 반환됨 ⇒ **메모리에 기록**
    - 디스크립터 : 소켓을 식별하기 위해 사용하는 것
      컴퓨터 내부에서는 복수의 데이터 송 수신 동작이 동시에 진행되는 경우
      ex. 브라우저에서 2개의 창을 열어 2개의 웹서버에 동시에 액세스한다면, 2개의 데이터 송수신이 동시에 진행, 2개의 소켓을 만들어야 함
      ⇒ 이때, 복수의 소켓을 식별하는 것
    - 소켓을 만든 후, 소켓을 사용하여 파이프 연결(접속) 및 데이터 송 수신할 때,
      **프로토콜 스택이 어떤 소켓을 사용하여 접속(/데이터송수신)할지 판단하는 기준이 된다**

### 2) 파이프 연결 (접속)

- 애플리케이션이 만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰한다.

  : 애플리케이션이 **소켓 라이브러리의 connect라는 프로그램 부품을 호출**한다.
  **connect를 호출하면, 프로토콜 스택이 파이프 연결(접속 동작)을 실행하고, 상대와 연결되면 프로토콜 스택은 연결된 상대의 ip 주소나 포트번호 등의 정보를 소켓에 기록한다. → 데이터 송수신이 가능한 상태가 됨**

- **connect를 호출할 때 디스크립터, 서버의 IP주소, 포트번호를 지정**한다
    - 디스크립터
        1. conncet는 프로토콜 스택에 최초의 디스크립터(소켓 생성시 반환된 디스크립터)를 통지
        2. 프로토콜 스택은 통지된 디스크립터를 보고 어느 소켓을 서버측 소켓에 접속할지 판단
        3. 접속 동작을 실행
    - 서버의 ip주소

      : 네트워크의 어느 컴퓨터인지 식별하기 위한 주소 (기기에 장착된 각각의 네트워크용 하드웨어에 할당된다)

    - 포트번호

      **접속동작은 상대측의 소켓에 대해 이루어지므로 소켓을 지정해야하는데,** ip주소로는 소켓을 지정할 수 없다

      포트번호를 통해 어느 소켓에 접속할지 분명히 지정할 수 있다.


- 세 가지 포인트
    1. **어느 소켓에 접속할 지 결정할 때, 포트번호가 아니라 디스크립터(소켓을 식별하는 번호표)를 사용하면 되지 않을까? ⇒ NO!**
       : 서브측 소켓의 디스크립터를 클라이언트에서 알 수 없으므로, 클라이언트에서 서버측의 디스크립트를 사용하여 서버측의 소켓을 지정할 수 없다.

       ⇒ **디스크립터는, 컴퓨터 한대 내부에서 복수의 소켓을 구분짓기 위해 사용** ↔ **포트번호는, 접속 상대측(클라이언트)에서 서버의 소켓을 식별하기 위해 사용**

       detail : 디스크립터는 소켓을 만들도록 의뢰한 애플리케이션에 건네주는 것이지, 접속 상대에 건내주는 값이 아니므로, 접속 상대 측(클라이언트)에서는 그 값을 모른다. 즉, 서브측 소켓의 디스크립터를 클라이언트에서 알 수 없으므로, 클라이언트에서 서버측의 디스크립트를 사용하여 서버측의 소켓을 지정할 수 없다.

    2. 서버측의 포트번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다.
       ex. 브라우저의 웹서버에 액세스할 때의 포트번호는 80번
  
    3. **서버에서 클라이언트 측의 소켓에도 연결할 때, 클라이언트의 소켓을 어떻게 구별할까?**
       클라이언트 측에서 **소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 소켓의 포트번호를 할당한다.
       이 값을, 프로토콜 스택이 접속 동작(파이프 연결)할 때 서버측에 통지한다.** 

프로토콜 스택은 어떻게 파이프를 연결하는가 + 프로토콜 스택이 어떻게 데이터를 전송하는가는 chapter2에서 설명한다

**질문 : 디스크립터가 저장되는 메모리란?**

### 3) 데이터를 송 수신

소켓이 상대측과 연결되면, 소켓에서 데이터를 쏟아부으면 상대측의 소켓에 데이터가 도착한다.

애플리케이션은 소켓을 직접 다룰 수 있음. ⇒ 소켓라이브러리의 write라는 프로그램 부품을 사용해 ⇒ 프로토콜 스택이 데이터 송 수신 하도록 함

- 데이터 송 수신 과정
    1. 애플리케이션이 송신 데이터를 메모리에 준비
       : url 바탕으로 리퀘스트 메시지
       2. 소켓라이브러리의 write라는 프로그램 부품을 호출
       : 이때, 디스크립터와 송신 데이터를 지정
       3. 프로토콜 스택이 송신 데이터를 서버에 송신함
       : 이때는 소켓에 연결된 상대가 기록되어 있으므로, 디스크립터로 소켓을 지정해, 그곳으로 데이터 송신
       4. 서버는 수신동작을 실행하여 받은 데이터 내용 조사하고 처리해서 응답 메시지를 반송


    5. 응답 메시지가 돌아오면, 메시지를 수신
    6. 소켓 라이브러리의 read라는 프로그램 부품을 호출해,
       프로토콜 스택에 수신 동작을 의뢰
    7. read가 응답메시지를 **수신 버퍼에 저장**한다.
    * **이때 수신한 응답 메시지를 저장하기 위해, 애플리케이션 프로그램의 내부에 마련된 메모리 영역** = 수신 버퍼
    8. 수신버퍼는 애플리케이션 내부 메모리 영역으로, 메시지 저장한 시점에서 애플리케이션에 메시지를 건내주게 되는 것이다.

### 4) 연결 끊기 및 송 수신 종료

1. 브라우저가 데이터 수신을 완료하면 송 수신 동작이 끝난 것.
2. 소켓 라이브러리의 close라는 프로그램 부품을 호출해,
   프로토콜 스택에 연결 끊기 동작을 의뢰
3. 소켓 사이를 연결한 파이프가 분리되고 소켓도 말소됨

예) HTTP 프로토콜에서,

- 웹 서버 측에서 응답 메시지 송신 완료 후, 연결 끊기 동작을 실행 = 웹 서버에서 먼저 close 호출해 연결은 끊는다.
- **클라이언트 측에 전달**
- 클라이언트의 소켓도 연결 끊기 단계 진행
  : 브라우저가 read로 수신 동작을 의뢰했을 때, read는 수신한 데이터를 건네주는 대신 연결 끊겼다는 것을 통지.
  - 이후 브라우저도 close 호출해, 연결을 끊는다.

HTTP 프로토콜은 데이터 하나하나 별도의 것으로 취급하여, 접속 - 응답 메시지 송신 - 응답 메시지 수신 - 연결 끊기 라는 동작을 반복한다.

질문 : **애플리케이션이 송신데이터를 메모리에 준비한다고 하는데 이때 메모리란?**
