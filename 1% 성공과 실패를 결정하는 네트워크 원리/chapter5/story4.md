# Story 4. 캐시 서버를 이용한 서버의 부하 분산

## 1. 캐시 서버의 이용
> 서버의 부하 분산을 하는 방법에는 `역할에 따라 서버를 나누는 방법`도 있다.  
> 그리고 역할 별 분산 처리 방법 중 하나가 **캐시 서버**를 이용하는 것이다.  

<br><br>

### 캐시 서버
> **프록시 구조**를 이용한 데이터를 캐시에 저장하는 서버  

* 프록시는 웹 서버와 클라이언트 사이에서 **웹 서버에 대한 액세스 동작을 중개하는 역할** 을 한다.  
* **캐시 기능**(데이터를 디스크에 저장하고 웹 서버 대신 데이터를 반송하는 역할)을 이용


<br><br>

### 캐시 서버의 이점
> 웹 서버는 많은 작업(URL 점검, 액세스 권한 점검, 데이터 내장 처리 등)을 담당하기 때문에, 데이터를 송신할 때 다소 시간이 걸린다.  
> 캐시 서버는 보존해 둔 데이터를 읽어서 송신하므로 빠르게 데이터를 송신할 수 있다.  

웹 서버의 데이터가 변경될 수 있고 CGI 애플리케이션이 출력하는 페이지 데이터도 내용이 매번 달라지므로 언제나 캐시 데이터를 시용할 수 있는 것은 아니다.  
하지만 일정 부분은 캐시 서버에서 처리할 수 있다.  

- 캐시 서버에서 액세스 동작을 고속화 한다면 전체 성능 향상이 가능하다.  
- 캐시 서버에서 요청을 처리하는 만큼 웹 서버의 부하가 줄기 때문에 웹 서버 처리 시간을 단축시킬 수 있다.  

<br><br><br><br>

## 2. 캐시 서버는 갱신일로 콘텐츠를 관리한다.  

### 캐시 서버의 동작

- 웹 서버를 대신해 캐시 서버를 DNS 서버에 등록한다.  
- 사용자는 캐시 서버에 요청을 보낸다.  
- 캐시 서버가 메세지를 수신한다.  
- 캐시 서버는 접속을 기다리는 패킷을 생성하고, 사용자 접속 시 접속 동작을 실행한다.  
- 캐시 서버는 리퀘스트 메시지를 받으면 내용을 조사하고, 자신의 캐시에 저장된 데이터인지 조사한다.  
  - 캐시에 데이터가 등록되어 있지 않은 경우 (A)
  - 캐시에 데이터가 등록되어 있는 경우 (B)
- 어느 웹 서버에 리퀘스트 메시지를 전송할지 판단 후 리퀘스트 메시지 전송  

<br><br>

### A:  캐시에 데이터가 등록되지 않은 경우 캐시 서버의 동작
- `Via` 헤더를 추가하여 웹 서버에 리퀘스트 전송.  
  - `Via` 헤더를 추가: 캐시 서버를 경유한 것을 나타냄 (캐시 서버에 따라 추가하지 않을 수 있음)
- 응답 메시지를 캐시에 저장하고 저장한 일시 기록
- 클라이언트에 보내는 메시지에 `Via` 헤더를 추가하고 응답한다.  

<br><br>

### B:  캐시에 데이터가 등록된 경우 캐시 서버의 동작
- 웹 서버에 데이터가 변경되었는지 조사
  - `Ìf-Modified-Since` 헤더 추가하여 리퀘스트 전송 (저장한 날짜)

- 웹 서버에서 데이터가 변경되었다고 응답하는 경우  
  - 새로운 데이터를 저장하고, 클라이언트에 보내는 메시지에 `Via` 헤더를 추가하고 응답한다.

- 웹 서버에서 데이터가 변경되지 않았다고 응답하는 경우
  - 캐시에 있는 데이터를 포함하여 클라이언트에 보내는 메시지에 `Via` 헤더를 추가하고 응답한다.  

<br><br>

### 캐시 서버가 송신할 웹 서버를 판단하는 방법    
> 서버가 한 대면 그냥 보내고 여러 대라면 판단해야함  
> 여러 방법이 있지만 대표적인 방법은 `리퀘스트 메시지 URI`의 디렉토리를 보고 판단하는 것    

```plain
/dir1/ -> www1.lab.cyber.co.kr
/dir2/ -> www2.lab.cyber.co.kr
```

<br><br>

### 이점
- 웹 서버는 데이터의 최종 갱신 일시를 조사하는 것만 하면 되기 때문에 데이터를 보내는 것보다 부담이 적음  

<br><br><br><br>

## 3. 프록시의 원점은 포워드 프록시이다.  
> 앞에서 설명한 내용은 서버 측에 프록시를 두는 것    
> 클라이언트 측에 캐시 서버를 두는 방법도 있다.  



프록시 구조의 원형은 `포워드 프록시`이다.  

<br><br>


### 포워드 프록시
> 캐시를 이용하는 것을 목적으로 등장  
> 방화벽을 실현한다는 목적도 가짐  

방화벽의 이용 목적은 인터넷에서의 부정 침입을 막는 것이다.  
이를 위해 필요한 것만 통과 시키는 방법을 실현하기 위해 고안한 것이 `프록시 구조` 이다.  
프록시에서 요청을 받고 인터넷에 전송하면 필요한 것을 통과시킬 수 있다.   

<br><br>


### 프록시의 이점  
- 프록시는 리퀘스트 내용을 조사하고 전송하기 때문에 내용에 따라 액세스가 가능한지 판단 가능  
- 즉, 위험한 사이트, 관계 없는 사이트에 대한 액세스를 제한할 수 있음  
(패킷 필터링형 방화벽은 IP주소, 포트번호로 판단하므로 이렇게 자세히 조건 설정하는건 불가능)  

<br><br>


### 포워드 프록시의 동작
- 브라우저 설정 화면에 프록시 서버라는 항목에 포워드 프록시의 IP 주소를 설정한다.  
- 리퀘스트를 모두 포워드 프록시에 보냄
  - 포워드 프록시를 사용 안 할 경우, URL에 따라 웹 서버를 계산하고 요청해아 함
  - 리퀘스트 메시지도 달라진다(프록시를 사용하지 않으면 파일이나 프로그램의 경로를 추출해야 함)
    ```
    GET /sample3.htm -> GET https://www.cyber.co.kr/sample3.htm
    ```

<br><br>
<br><br>


## 4. 포워드 프록시를 개량한 리버스 프록시
> 포워드 프록시는 브라우저에 대한 설정이 필요하다.  
> 브라우저 설정은 번거롭고, 잘못된 경우 브라우저가 제대로 작동하지 않을 수 있다.  

웹 서버는 누가 액세스 하는지 알 수 없다.  
그리고 브라우저에 프록시를 설정할수도 없다.  
그래서 브라우저에 프록시를 설정하지 않아도 사용할 수 있도록 개량되었다.  

리퀘스트 메시지의 URI에 적혀있는 디렉토리명과 전송 대상의 웹 서버를 대응 시켜 리퀘스트 메시지를 전송할 수 있도록 함  
(`http:// ~`라고 안써도 일반 리퀘스트 처리가 가능하도록)  

<br><br><br><br>



## 5. 트랜스페어런트 프록시
> 캐시 서버에서 전송 대상을 판단하는 방법으로 리퀘스트 메시지 패킷의 헤더를 조사하는 방법이 있다.  
> 수신처 IP를 확인해 웹 서버가 어디있는지 알 수 있는데 이 방법이 트랜스페어런트 프록시이다.  

### 다른 프록시 방법과의 차이점
- 포워드 프록시처럼 브라우저에 설정할 필요 없음  
- 리버스 프록시처럼 캐시 서버에 설정할 필요 없음  

<br><br>


### 특징
> 포워드 프록시와 리버스 프록시의 장점만 모은 구조이다.  
> 하지만 트랜스페어런트 프록시에 리퀘스트 메시지를 건네주는 방법을 주의해야한다.  

- 브라우저는 웹 서버에 메시지를 보낸다(브라우저 설정 X, DNS 등록 X 때문에).
- 브라우저에서 웹 서버로 리퀘스트 메시지가 흘러가는 길에 트랜스페어런트 프록시를 설치해야 한다.  
- 트랜스페어런트 프록시를 통과할 때 메시지를 가로채고, 이후에 웹 서버에 전송함
- 리퀘스트 메시지가 흐르는 길이 많으면 길이 한 개로 수렴하는 형태로 네트워크를 만들고, 수렴하는 곳에 트랜스페어런트 프록시를 설치한다.  
- 트랜스페어런트 프록시를 사용하면 사용자가 프록시의 존재를 알아차릴 필요가 없다.    

