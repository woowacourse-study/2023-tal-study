# story2. 서버의 수신 동작

> 클라이언트가 보낸 패킷이 서버에 도착한 부분부터 순서대로 다시 살펴본다.

## 1. LAN 어댑터에서 패킷의 신호를 디지털 데이터로 변환

### 디지털 데이터 변환
> LAN 어댑터에서 받는 패킷의 신호는, 1과 0으로 이루어진 데이터 신호와 타이밍을 나타내는 클록 신호를 합성한 것이다.   
> 클록 신호를 이용해, 패킷의 전기 신호를 디지털 데이터로 변환한다.  
> 전송 속도에 따라 신호의 형식, 세부적인 동작이 다르나 책에서는 10BASE-T 를 기준으로 설명한다.

- 클록 펄스(Clock Pulse): 같은 시스템 내 동작하는 각 구성 요소의 동작을 동기화하기 위해 사용되는 전자적 펄스
- 프리앰블(전송 타이밍을 맞추기 위해, 먼저 보내는 신호) 부분은 신호가 일정 간격으로 규칙적으로 변화한다.
- 따라서 프리앰블 부분의 신호가 변화하는 타이밍을 조사하여 클록을 추출하고, 데이터 신호 길이에 맞게 연장한다.
- 클록의 위치에서 데이터 신호의 변화 방향을 조사해, 이를 1과 0으로 바꿀 수 있다.
<img width="433" alt="image" src="https://github.com/woowacourse-study/2023-tal-study/assets/97426362/6ef3cc76-d918-41ba-9315-deb7e3506025">

### FCS 검사 및 수신처 MAC 주소 조사
> 디지털 데이터로 변환을 마친 후, 패킷의 맨 마지막에 있는 프레임 체크 시퀀스(FCS)를 이용해 오류 유무를 검사한다.  
> FCS가 일치하고 오류가 없으면, 자신에게 보내는 패킷인지 판단하고 LAN 어댑터 내부의 버퍼 메모리에 저장한다.

- FCS에는 송신할 때, 디지털 데이터를 바탕으로 헤더와 데이터에 대해 계산한 값을 넣어둔다.
  - 수신 측에서 신호를 되돌려 얻은 디지털 데이터를 바탕으로 계산을 한 값이 FCS와 같은지 확인한다.
  - 양쪽의 FCS 값이 일치하지 않으면, 패킷을 버린다.
- MAC 헤더의 수신처 MAC 주소를 조사해 자신에게 온 패킷인지 판단한다.
  - 수신처가 자신이 아니면, 패킷을 버린다.
- 여기까지는 LAN 어댑터의 MAC 부분에서 수행하는 일이다.

### 인터럽트, 프로토콜 스택 호출까지
> 수신 처리를 위해 LAN 어댑터에서는 인터럽트라는 방법으로 CPU에 패킷의 도착을 알린다.   
> CPU는 LAN 드라이버를 동작해 패킷을 추출하고, 헤더 내용에 따라 프로토콜 스택을 호출해 패킷을 전달한다.

- 서버의 CPU는 패킷의 도착을 감시하고 있지 않다. 다른 일을 실행하고 있기에 패킷을 알아차리지 못한다.
- 인터럽트를 통해 CPU에 패킷의 도착을 알리면, CPU는 실행하고 있던 작업을 중단하고 LAN 드라이버로 실행 전환한다.
- LAN 드라이버는 LAN 어댑터의 버퍼 메모리에서 패킷을 추출한다.
- MAC 헤더의 타입 필드 값에서 프로토콜 판별, 프로토콜을 처리하는 소프트웨어를 호출한다.
  - IP 프로토콜이면, TCP/IP의 프로토콜 스택을 호출한다.

## 2. IP 담당 부분의 수신 동작
> IP 헤더를 점검하고, 자기 자신에게 온 패킷인지 중계할 패킷인지 판단한다.  
> 자신을 대상으로 할 경우 조각 나누기 여부를 조사하고 패킷을 복원해 알맞은 프로토콜 담당에 넘겨준다.

- IP 헤더의 수신처 IP 주소가 자신을 대상으로 하는지 조사한다.
  - 서버가 라우터 역할도 할 경우, 자신을 대상으로 하지 않는 패킷이 올 수도 있다.
  - 자신을 대상으로 하지 않으면 경로표를 조사해 패킷을 중계한다.
- 자신에게 온 패킷이라면 헤더를 통해 조각 나누기 여부를 확인한다.
  - 분할된 패킷이면, 일시적으로 메모리에 저장해둔 뒤 나머지 패킷을 모두 받은 시점에 이를 조립한다.
- IP 헤더의 프로토콜 번호 항목에 맞는 프로토콜 담당 부분에 패킷을 넘겨준다.
  - 프로토콜 번호 항목 06(16진수) -> TCP
  - 프로토콜 번호 항목 11(16진수) -> UDP


> TCP 담당 부분의 동작은, 접속을 시작하는 경우와 접속 이후 데이터 패킷을 수신하는 경우에 따라 동작이 달라진다. (3-1, 3-2)
## 3-1. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작
> SYN 컨트롤 비트 확인, 수신처 포트 번호를 통해 접속 가능 여부를 조사한 후 새 소켓을 작성해 필요한 정보들을 기록한다.  
> 접속 동작을 위한 패킷을 클라이언트에 반송한다.
### 접속을 시작할 수 있는지 확인하기
  - TCP 헤더에 있는, SYN이라는 이름의 컨트롤 비트가 1로 되어 있어야 접속 동작의 패킷이다.
  - 패킷의 수신처 포트 번호에 해당하는 접속 대기 상태의 소켓이 있어야 한다.
    - 없으면 오류 통지 패킷을 클라이언트에 반송한다.
### 접속 동작
- 접속 대기 소켓이 있으면, 패킷을 복사해 새 소켓을 만든다.
- 새 소켓에 필요한 정보를 기록한다.
    - 송신처 IP 주소, 포트번호, 시퀀스 번호의 초기값, 윈도우 값 등
- 접속 동작을 위한 패킷을 클라이언트에 반송한다. 이 패킷에는 데이터 없이 TCP 헤더뿐이다.
  - TCP 헤더에는 ACK 번호, 데이터에 대한 시퀀스 번호 초기 값, 윈도우 값 등의 항목을 기록한다.
  - 이 패킷을 받은 클라이언트가 다시 패킷을 보내 ACK 번호를 주면, 접속 동작이 완료된다.
- 서버 측의 어플리케이션은 accept를 호출해 접속을 접수하고, 실행을 쉬는 상태가 된다.
  - 새로 만든 소켓의 디스크립터를 전달해 동작을 재개할 수 있다.

## 3-2. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작
> 도착한 패킷에 맞는 소켓을 판단하고, 데이터 조각을 연결해서 수신 버퍼에 보관한 후 클라이언트에게 ACK를 되돌려준다.
### 도착한 패킷에 맞는 소켓을 판단하기
  - 송신처 IP주소, 송신처 포트 번호, 수신처 IP 주소, 수신처 포트 번호
  - 위 네 가지가 모두 합치되는 소켓을 찾는다.

### 데이터 수신 동작
- 소켓에 기록된 정보와, 패킷의 TCP 헤더의 정보를 가지고 데이터 송수신 동작이 정상적으로 이루어지는지 점검한다.
  - 소켓에 기록된 지난 시퀀스 번호, 지난 데이터 조각의 길이로부터 다음 시퀀스 번호의 값을 계산하여 실제로 받은 패킷의 TCP 헤더에 기록된 시퀀스 번호와 같은지 비교한다.
- 패킷에서 데이터 조각을 추출하여 수신 버퍼에 저장해, 분할된 데이터들을 연결한다. -> 수신 동작 끝
- 수신 확인 응답용 패킷을 클라이언트에 반송한다. 
  - TCP 헤더에는 수신 패킷의 시퀀스 번호와 데이터 조각의 길이로부터 계산한 ACK 번호를 기록한다.

### 어플리케이션의 수신 동작
- 수신 버퍼에 데이터 조각을 보관한 이후, 어플리케이션이 Socket 라이브러리의 read를 호출한다.
- 어플리케이션은 대기 상태가 되어 데이터를 전달받는다.
- 이후 서버 어플리케이션이 하는 일(HTTP 리퀘스트 메시지 내용 처리)은 별도 챕터에서 다룬다.

## 4. TCP 담당 부분의 연결 끊기 동작
> 데이터 송수신이 끝나면 연결 끊기 동작에 들어간다. 이 때의 동작은 서버측, 클라이언트측이 모두 같다.
- TCP 프로토콜 규칙에 따르면 클라이언트/서버 중 어느 쪽이 먼저 연결 끊기를 시작하든 상관 없다.
- 하지만 웹의 경우, HTTP 프로토콜 버전에 따라 다르고 HTTP/1.0이라면 서버에서 연결 끊기 동작을 시작한다.

### HTTP/1.0의 연결 끊기
- 서버 측 어플리케이션이 Socket 라이브러리의 close 를 호출한다.
- 연결 종료를 알리는 패킷을 클라이언트에 보낸다.
  - TCP 헤더에 FIN이라는 컨트롤비트에 1을 설정한 값을 담는다.
- 이를 받은 클라이언트는 ACK 번호를 반송하고, close를 호출 후 마찬가지로 연결 종료를 알리는 패킷을 서버에 보낸다.
- 서버가 ACK 번호를 반송한다.
- 연결 끊기 동작이 끝난 뒤, 잠시 기다렸다 소켓을 말소한다.

### HTTP/1.0과 HTTP/1.1의 연결 동작 차이
- 지속적인 연결의 지원
  - HTTP 1.0은 요청/응답이 끝날 때마다 항상 연결을 끊는데, HTTP 1.1은 Connection 헤더의 값 설정을 통해 지정한 timeout 시간 동안 연결을 끊지 않을 수 있다.
    - 매번 새로운 TCP 핸드셰이크를 하는 비용을 아끼기 위함이다.
    - Connection 헤더의 값은 기본적으로 keep-alive로 설정되어있고, timeout의 기본 값은 15초이다.  
  
그래서, HTTP/1.1에서는 클라이언트가 먼저 연결을 끊을 수 있다.  
- HTTP 1.0은 매번 새로운 연결을 만들기 때문에 클라이언트에서 먼저 연결을 끊으면, TCP 연결이 아예 닫힌다. 
  - 클라이언트 측이 연결을 끊은 걸 서버 측에서 인지하지 못하고 계속해서 응답을 보내는 문제가 발생할 수 있다.
  - 핸드 셰이킹은 이루어졌어도, 어차피 매번 새 연결을 만들기 때문에 클라이언트가 더 이상 연결을 하지 않는다는 걸 서버 측에서 알 수 없다.
- HTTP/1.1은 기본적으로 지속적인 연결을 지원하므로, 클라이언트가 연결을 끊을 때 바로 TCP 연결을 닫는 게 아니라 서버에 연결을 끊으라고 알려줄 수 있다.
  - Connection 헤더의 값을 close로 요청을 보내 서버에 연결을 끊으라고 알려준다. 일단 TCP 연결 상태는 유지한다. 
- 참고 링크 : https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x