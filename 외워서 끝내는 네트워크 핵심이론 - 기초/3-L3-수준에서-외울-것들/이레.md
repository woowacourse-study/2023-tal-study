# IPV4주소의 기본구조

- MAC주소는 L2계층에서 가장 중요하다
  IPV4는 32비트 = 8비트 *4
- 8비트 = 2의 8제곱
  8비트 숫자의 범위는 0~ 255(1111 1111 = 브로드캐스트 주소)
  ipconfig
- ip주소는 = 호스트에 대한 식별자(ip 인터넷 프로토콜 쓰는 인터넷망에서 연결된 컴퓨터 한 대를 식별하기 위해 부여한 고유번호)
  8비트씩 잘라서 dot으로 구분하여 표현한다.
- 네트워크 아이디(서울시 강남구 역삼동~)
  호스트 아이디(컴퓨터) (*번지)
  자르는 이유 : ip주소를 가지고 인터넷이 목적지까지 데이터 전송해야 함
  예) 고속도로 + 택배(물류체계)
  물류센터 추적
  강남구나 역삼동을 커버하는 지역 물류센터에 모든 택배들이 도착
  도착 시점에, 트럭까지
  네트워크 아이디 = 우리동네까지 진입. 어느동네까지 진입할것인지 알려줌
  그뒤에, 이 네트워크에 속한 host아이디를 찾기 시작함

# L3 IP 패킷으로 외워라

- 패킷 = 단위 데이터
  패킷은 IP프로토콜이고 레이어로 따지면 L3이다.
  패킷 = L3 IP 패킷으로 외워라
- 논리적으로 2덩이
  HEADER와 PAYLOAD로 나뉜다
- 패킷의 최대크기 = MTU 맥시멈 트랜스미션 유닛
  (보통 1500BYTE =1.4KB정도) 사이즈로 전송할 수 있는 데이터.
  퍼즐 조각하나라고 생각하면 된다. 송장 붙은 박스하나.
- 헤더 : 송장(소스(출발지)가 DST(목적지)로 간다)
  페이로드 : 헤더가 실어나르는 대상(택배 내용)
- 인터넷이라는 거대 논리 네트워크에서 (정보 유통체계에서) 최대크기가 1500바이트밖에 안된다.

와이어샤크(네트워크를 읽어서 패킷을 볼 수 있음)
목적지 MAC주소, SRC, 타입값(08 00)을 보고 그 뒤를 뭐로 해석할 것인지 +
네트워크에 돌아다니는 패킷을 무작위로 수집해서, 분석해서, 장애가 되는 원인을 찾거나 어떤 통신이 일어나는지 분석

# encapsulation과 decapsulation

- 패킷의 인캡슐레이션 = 마트료시카 인형같은 것
  박스안에 쏙 넣었다
  단위화 했다. 박스단위로
  포장했음 = 보이지 않음 = 안에 뭐가 있는지 모름
- ip 패킷 통째로 L2프레임의 페이로드가 됨
  L4세그먼트(TCP)통째로 L3 IP패킷의 페이로드가 된다


# 패킷의 생성과 전달

패킷 택배같은 것
철수가 책을 영희에게 보내려는데 택배라는 방법 이용

1. 박스에 넣고
2. 송장 붙임
3. 기사님에게 전달
4. 물류센터를 거쳐
5. 영희네 도착 (목적지 주소 보고)
6. 받는 사람 주소 + 이름 받는이
7. 받는 이의 이름에 따라서 구체적인 PC에 전달(영희 엄마 동생 중 영희에게 전달)

   = PROCESS(철수나 영희 프로세스)

- 즉, 정보 데이터를 패킷으로 만든 후 -> 기사님에게 전달

  기사님 = 게이트 웨이 (집의 현관이라는 인터페이스를 통해 게이트웨이에 데이터 전달됨)

- 게이트 웨이에게 전달된 정보는 택배 물류체계를 통해 택배를 라우트함(모았다 어쩄다한다)
- IP주소를 보고 영희네 집까지 감(영희 HOST까지)
- 그리고 이름을 보고 호스트 내부에서 어떤 프로세스인지 선택헤서 데이터 전달
  (이름 = 포트번호)

어떤 프로세스가 인터넷을 통해 데이터를 전달하려고 한다면?

- 소켓(=커널에 있는 TCP IP를 추상화한 인터페이스)

  = 파일의 일종. 유저모드 프로세스가 접근할 수 있도록 추상화한 인터페이스


1. 데이터를 이 파일에 WRITE함 (TCP소켓, 네트워크 = WRITE가 아닌 SEND라고 함)
2. 데이터가 TCP로 내려가면, (TCP, 데이터) = 세그먼트
3. IP로 내려가면 (IP, 세그먼트) = 패킷
4. 드라이버로 내려가면
   (이더넷 헤더, 패킷) = 이더넷 프레임인 채로 하드웨어를 타고 나간다
5. L2 액세스 스위치를 만나고,
6. 타고 올라가서 라우터 게이트웨이를 통해 인터넷으로 나간다

# **계층별 데이터 단위**

- 데이터의 단위
  L2(L1~L2) = 프레임
  IP수준 단위 = 패킷
  TCP = 세그먼트
- 유저모드 수준으로 오면, 소켓수준의 데이터 단위 = 스트림
  (*스트리밍 서비스의 그 스트림)

스트림의 특징

- 시작은 있으나 끝이 정확히정해져있지 않음
- 프로세스 어플리케이션 수준에서 정함

  ⇒ 데이터 송수신하는 운영체제 입장에서는 스트림은 연속적으로 이어진 크기를 알 수 없는 큰 데이터이다

- 소켓이라는 인터페이스에 대고 스트림을 WRITE하는 것

문제는 인터넷에는 데이터 단위가 정해져있음

- (패킷의 최대크기 MTU 1500바이트 + 세그먼트의 최대 크기 MSS 맥시멈 세그먼트 사이즈 = 대부분 1460바이트 정도)
- 만약 스트림의 전체 데이터가 4MB라면
  세그먼트가 가질 수 있는 최대 크기를 넘어감

따라서,

스트림을 잘라서 분할해서 세그멘트화 함(

소켓을 타고 내려가서 세그먼트화 될 때 분할=세그멘테이션 = MSS 단위로  자른다음 MTU사이즈에 맞춰 인터넷에 유통시킴)

- 유저모드 어플리케이션에서 스트림은, 단위는 아니지만 데이터 덩어리 그 자체이다.

데이터 그램 이라는 단위 DATAGRAM
(UDP프로토콜에서. 패킷하고 비슷함 = 정해진 데이터 덩어리)
하지만 보통 세그먼트 패킷단위가 가장 많이 쓰인다!!!!

# TCP/IP 송수신 구조

파리에서 에펠탑을 택배로 보내려면 어떻게?

1. 에펠탑 분해해, 박스로 보낼 수 있을만큼의 크기로 분해 MTU크기
2. 운송(패킷단위로 데이터 유통됨)
3. 조립
4. 분해 = 송신측
5. 조립 = 수신측

PC – L2스위치 – 라우터 거쳐서 – 인터넷 도착 – 라우터 – L2액세스 – 네이버 서버

네이버에서 파일 하나 다운받는다고 하면

- 네이버 서버에서 파일을 송신 예1.4MB
- 인터넷 구간에서 정보 유통될 때 패킷의 형태로
  MTU=1.4KB(대략 1024배)
  ->대략 천개 이상의 패킷으로 나누어서 보내야함
- PC에서 수신
  정확히는 PC에서 작동중인 프로세스가 파일을 보내고 받음
- 파일을TCP/IP로 보낸다 = 연결지향프로토콜(전화를 받으면 연결됐다고 하는 것과 같음)

  TCP연결 됐다는 가정하에 송수신이 이뤄진다


### 인캡슐레이션

1. 소켓 = 본질은 파일 = 커널의 구성요소인 TCP 프로그램에 대한 추상화된 인터페이스
   즉, 프로세스가 파일에 대고 입출력이 이뤄지는 것인데
  - 입출력이 일어날 때, 소켓에 어태치된 메모리공간 = 버퍼가 있다.
    버퍼가 있으면 버퍼드 입출력
    없으면 넌버퍼드 입출력IO
  - 서버 프로그램 안에서 개발자가 파일을 읽어와야 하기 떄문에 버퍼가 있음
    서버프로그램 안의 버퍼 크기는 개발자가 정하기 나름.

예) 파일명 A.bmp 라는 1.4MB의 파일
몽땅 메모리로 올릴 수도 있고 나눠서 올릴 수도 있음

1. 직소퍼즐 다섯 개만 잘라서 프로세스 버퍼에 보냄

   ⇒ 메모리에 원본 파일이 있는 데이터를 긁어와서 COPY후,

   ⇒ 읽어와서 프로세스가 메모리에 담는다

   ⇒ 버퍼에 넣음

   ⇒ 버퍼에서 소켓 버퍼로 카피(파일에 SEND)

   네트워크에서 입출력은 SEND /RECIEVE

2. 전송이 일어나는데 유저모드에서 커널로 넘어갈 때, TCP를 만나는데, 이지점에서 분해가 일어다.

   : 퍼즐처럼 잘려서 올라가는 게 아니고 이때 퍼즐조각으로 잘리는 것

   ⇒ TCP쪽에서 IO가 일어나서 네트워크로 보내줘하면 분해가 일어남

   이때, 파일에 어태치된 데이터들의 단위 = 스트림(스트림은 파일 전체 읽어서 보내면 끝남)

   ⇒ TCP스택을만나 세그멘테이션

   = 데이터를 분해하는 순간 TCP에서 세그먼트가 된다. 순서 1번 등 번호표를 붙여줌

   데이터 상태일때는 번호 없었음

   ⇒ 세그먼트화 된 데이터가 한층을 내려가면,

   IP는 택배다 = 세그먼트를 택배 박스 안에 넣는 것 (포장

   이 박스속에는 세그먼트 1번이 넣어지고, 송장이 붙는다 = 패킷

   ⇒ 이 패킷을 드라이버 L2로 가면,

   택배기사님께 전달하기 위해, 택배기사의 트럭에 박스에 넣음(트럭 = 프레임)

   ⇒ 트럭이 목적지까지 한방에 가나?

   **프레임(트럭)은 유통과정에서 계속 수시로 바뀐다**

   보낼 때, 세그먼트 1,2,3 등 택배(패킷)을 연달아 보낼 수도 있고 WAIT할 수도 있다
   보통은 특별한 이유가 없으면  2번을 바로 전송한다(순서대로)


### 디캡슐레이션

1. 도착한 트럭(출발한 트럭 사라짐)
2. L2수준에서 하차가 일어남 (프레임에서 패킷 꺼냄)

   프레임에서 패킷 꺼내면 프레임은 사라진다

   ⇒ IP에서 패킷

   ⇒ TCP에서 세그먼트(버퍼에서 카피된 데이터에서 분해된 데이터, 순서가 있음)

3. 세그먼트가 유저모드의 소켓 입출력 버퍼로 순서대로 올라간다
4. TCP스택에서 여유공간이 있을 버퍼를 채워준다.

   예) [1번세그먼트]

5. 프로세스는 IO버퍼로부터 데이터를 끄집어내서 프로세스 버퍼로 옮겨준다 READ인데 네트워크니까 RECIEVE 속도차가 있다
  - 네트워크에서는 IO버퍼를 채워나가고, 프로세스는 IO버퍼를 비움.
  - (채워짐) (비움)이 동시에 일어나면서 여유공간이 계속 생긴다
6. TCP는 수신측에서 연결제한
  - (TCP가 받으면, 잘 받았다고 피드백을 줌 ACK#3 = 1,2번까지 잘 받았다.)
  - 보내는 입장에서 송신을 하면, WAIT를 걸고, 잘 받았는지 피드백을 기다린다
  - ACK#3이 오기를 기다리다가, 수신측에서 ACK#3을 보냄
  - 그 뒤에 송신측이 3번을 보낸다. 이과정이 계속 반복된다

   ACK가 갈 때 같이 라가는 정보들 중에 여유공간*(TCP는 데이터를 보낼 때 상배방이 여유공간을 가지고 있는지 확인한다. 없으면 못보냄)


### 대표적인 TCP 관련 장애

- 가장 밑단, 하드웨어 수준에서(네트워크수준에서 나는 것) LOSS

  = LOST세그먼트. 택배가 오다가 유실됨 = 네트워크 문제

- RE-TRANS~~~

  ACK보냈는데 ACK응답이 없음면 다시보낼 때가 있음.
  ACK를 보냄과 동시에 또 다시보냄
  예)1,2번을 보냈는데 ACK3이 안와. 1,2를 다시 보냄. 수신측에서는 ACK를 또 보냄
  ACK가 중복되어서 생기는 네트워크문제 혹은엔드포인트간 문제

- OUT OF ORDER 1,2,3번 와야하는데 1,2오고 4가 와버림 = 거의 네트워크 문제
  4를 수신하는 순간
  혹은 4가 온 순간 3번이 뒤이어 옴
  일정순간 TCP스택에서 일정수준 보정을 하게 된다
- ZERO WINDOW 수신측에서 소켓IO의 여유공간을 WINDOW SIZE라고 부른다 이게 제로가 되었다. 네트워크는 안정적으로 버퍼를 채웠는데 프로그램이 빠르게 버퍼를 비워주지 못하고, 여유공간이 꽉참
  네트워크의 송수신속도가> 프로세스의 데이터 처리속도
  여유공간이 꽉차면 수신자가 데이터 수신할 수 없음
  이런 경우, 엔드포인트 단계에서 어플리케이션 문제. 프로그램에서 문제를 찾아야한다.

### 버퍼?

HDD나 SSD라는 보조기억장치 안에 FILE이 저장되어있음
예) FILE의 크기가 1.4MB

# IP 헤더 형식

- 헤더~페이로드지 늘어날 수 있는 최대크기 MTU 1500바이트
- IP헤더.
  옵션이 붙지 않는다면 약 20바이트 가량
  옵션이 붙으면 더 늘기도 함
  페이로드는 대략 1480정도
- 최대 아이디 패킷이 64K 까지
