# 수강 전에 알고 있다고 가정하는 것들

# 1. 수강 전에 알고 있다고 가정하는 것들

- bit, byte 정보 표현의 단위를 알고 있다.

  : 1 byte는 8bit이다

- **bit 단위 논리 연산**을 할 수 있다.
- 2진수를 16 진수로 변환할 수 있다.
- 1024MB 가 1GB임을 알고 있다.
    - KB → MB → GB → TB 단위도 알고 있어야 한다.
- **process 와 program의 차이**를 알고 있다.
- **OSI 7 layer**를 알고 있다.
- **범용 운영체제는 `User mode`와 `Kernel mode` 가 존재한다는 것을 알고 있다.**
- **Buffer의 의미**를 알고 있다.

  : 버퍼를 채우는 게 버퍼링(정보가 유입되는 공간, 버퍼가 차면 화면에 재생됨)

- 개념(abstraction)과 구현(implementation) 의 차이를 알고 있다.

### Bit단위 논리연산

- And 연산(&)

  : 대응되는 두 비트가 **모두 1일 때만 1을 반환**하며, 다른 경우는 모두 0을 반환합니다.

- Or 연산(|)

  : 대응되는 두 비트 중 **하나라도 1이면 1을 반환**하며, 두 비트가 모두 0일 때만 0을 반환합니다.

- XOr 연산(^)

  : 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환합니다.

- Not 연산(~)

  : 비트를 1이면 0으로, 0이면 1로 반전시킴

- 시프트 연산자(<<)

  : 지정한 수만큼 비트들을 전부 왼쪽으로 이동시킴.

  이진수의 끝을 벗어난 비트는 손실된다.

  예) 3(0011)<<3 = 8(1000)

- 시프트 연산자(>>)

  : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴.


### Mask 연산

### process와 program의 차이

- A process is a program in execution (실행중인 프로그램)
- Program이란?
    - **파일 시스템이 존재**하는 실행파일
    - .exe로 끝나는 파일들
- Process란?
    - 프로그램을 클릭하면, 운영체제가 프로그램을 실행함
    - **프로그램을 실행 시키는 실행 주체** = **인스턴스** = CPU를 차지하면서 **프로그램을 수행하는 수행 주체**
    - 프로그램은 하나지만 **이 프로그램을 실행하는 인스턴스는 여러 개가 생길 수 있다.**
    - **포트번호(어플리케이션 계층)로 구분할 수 있는 실행단위**
    - 프로세스가 포트번호로 식별한다면,

예를 들어,

- 한글 문서 실행파일 HWP.exe
- 한글 문서 편집 시, 여러 개의 한글 창을 띄울 수 있음
- 하나의 한글 창 = 하나의 프로세스
- 또, 한글에서 문서 출력을 하려고 print를 눌렀다
- 프린트 작업이 cpu에 올라가서 수행됨 = 이것도 또 다른 프로세스가 된다

# 2.  Layer Layered 구조

- 레이어 구조
  : 구성 요소 간의 관계를 표현하기 위해 도식화한 것
  : **시스템을 이루는 요소간의 관계를 정의**를 위한 표준화된 문법

  예) 4층은 3층에 의존적인데, 행위/기능에 대해서(한정해서) 의존적(범위가 제한적일 수 있음)이다.

- 존립에 대한 의존 = 의존 정도가 굉장히 높다

  예) 학사 위는 고등교육 이수를 전제로 한다(존립의 의존적이다)

  예) 3은 4의 전제조건이다. (4는 3을 전제로 한다= 존립이 의존적이다)

- 일렬종대로 존립이 의존적인 경우 아래와같이, 일렬된 그림으로 나타난다.
  4
  3
  2
  1

**즉, Layered 구조란?**

- 규칙들을 **계층구조**로 나열한 것
- **Layered 의존적 관계를 모두 성립**했을 때, **상호작용이 성립**한다.

# 3. 네트워크와 네트워킹 그리고 개념

- 네트워크 (관계)
- 네트워킹 (네트워크를 기반으로 상호작용)

  예) 철수 –올리비아가 상호작용(네트워킹)하는데
  3 (수단)언어
  2 음성 언어로, EMAIL
  1 공기 중, 2M 거리
  위와 같은, layered의 의존 관계(네트워크)를 모두성립했을 때 상호작용이 성립한다.

- 프로토콜 : 계층별 규칙(의존적 관계가 성립하는 규칙)
- OSI 7layers = 규칙을 계층구조로 나열한 것

### 개념

7layers은 개념이다.

예)
연예인(요소) = 개념
|
|- 관계: 상속 관계
|
박은빈(일종) = 개념에 대한 실제적 사례, 구현

예2)

**TCP/IP 프로토콜(규칙)은 구현에 해당된다**
위의 프로토콜(구현)이 무엇에 대한 구현인지 전송계층, 네트워크, 전송 등의 개념에 대한 공부는 필요 없다

# 4. USER MODE와 KERNEL MODE

- RAM카드 : 하드웨어 중, NIC(네트워크 인터페이스 카드)
- 드라이버 : 하드웨어 제어하기 위한 소프트웨어

  ⇒ Ram카드를 사용하기 위해(제어하기 위해) 드라이버 설치해야한다

- USER MODE

  :브라우저(파일 형태로 전달하는데 이 형태를 소켓이라고 부른다)

- KERNEL MODE

  : OS (OS가 지정한 인터페이스 형태로 데이터를 전달해야함)
  : 커널 프로토콜이 구현된 소프트웨어(TCP/IP형태로 구현되어있음)

- 레벨

  유저모드 = 프로세스 수준
  전송계층(tcp) = os 수준


user mode
kernel mode
sw 드라이버
hw

유저모드에는 파일이 존재하는데,
소켓은 네트워크 추상화가 이뤄진 파일이고, 소켓을 여는 주체가 프로세스이다.

### 추가적 공부

**모드를 나눈 이유**

**:** 커널에서 중요한 자원을 관리함. 사용자가 그 **중요한 자원에 접근하지 못하도록** 모드를 2가지로 나눈 것

예를 들어, 어떤 사람이 하드디스크의 내용을 전부 지워버리는 악의적인 프로그램을 만듦

- 이 어플리케이션 프로그램이 I/O장치에 직접 접근한다면, 중요한 자료들이 전부 날아갈 것임
- 따라서 운영체제를 통해서만 I/O 장치를 사용할 수 있도록 함

  예) A프로그램이 “디스크에서 어떤 데이터 좀 읽어줘”(프로그램 수행 중= 프로세스 =유저 모드)

  -> 운영체제가 데이터를 읽어서, A프로그램에 정보를 넘겨줌

  (이때, 프로그램은 interrupt되고, **운영체제가 호출 되어 수행되는 모드 = 커널 모드**)


**User Mode**

- 유저(사용자)가 접근할 수 있는 영역을 제한 하여,

  시스템 데이터에 제한된 접근만 허용 + 하드웨어엔 직접 접근 불가

  ⇒ 프로그램의 자원에 함부로 침범하지 못하는 모드이다.

- 우리는 여기서 코드를 작성하고, 프로세스를 실행하는 등의 행동을 할 수 있다.
- 간단하게 "**유저 어플리케이션 코드가 유저모드에서 실행된다.**" 라고 말할 수 있다.

**Kernel Mode**

- 모든 자원(드라이버, 메모리, CPU, I/O 등)에 접근할 수 있고, 모든 cpu 명령을 실행 할 수 있다.
- 유저 애플리케이션에서 시스템 서비스 호출하면 유저모드에서 커널모드로 전환된다

os(운영체제)가 cpu를 관리

cpu상태(유저모드, 커널모드)를 바꾸면서 프로그램 수행

Docker를 사용하여 포트번호 13306을 호스트 컴퓨터와 연결된 포트 3306에 매핑(mapping)하는 것을 의미합니다.

여기서 3306은 MySQL 데이터베이스 서버에서 사용하는 기본 포트번호입니다.

즉, Docker 컨테이너 안에 MySQL 서버가 실행 중이고, 이 MySQL 서버에 접속하기 위해 호스트 컴퓨터에서는 13306 포트를 이용하여 접속할 수 있습니다.

예를 들어, 호스트 컴퓨터에서 MySQL 클라이언트를 실행하여 Docker 컨테이너 안에 있는 MySQL 서버에 접속하려면, 다음과 같은 명령어를 사용할 수 있습니다.

```
mysql -h localhost -P 13306 -u username -p password

```

이 명령어는 호스트 컴퓨터의 13306 포트를 통해 Docker 컨테이너 안의 MySQL 서버에 접속하겠다는 의미입니다.
